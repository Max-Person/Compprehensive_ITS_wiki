<!DOCTYPE html> <html lang="en"><head>
<title>Узлы</title>
<base href="../..">
<meta name="pathname" content="1.-модели-(its_domainmodel)/дерево-решений/узлы.html">
<meta name="description" content="Compprehensive ITS wiki - Узлы">
<meta property="og:title" content="Узлы">
<meta property="og:description" content="Compprehensive ITS wiki - Узлы">
<meta property="og:type" content="website">
<meta property="og:url" content="1.-модели-(its_domainmodel)/дерево-решений/узлы.html">
<meta property="og:image" content="images/nodes_branchresultnode.png">
<meta charset="UTF-8"><meta property="og:site_name" content="Compprehensive ITS wiki"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0"><link rel="alternate" type="application/rss+xml" title="RSS Feed" href="site-lib/rss.xml"><script async="" id="webpage-script" src="site-lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="site-lib/media/favicon.png"><link rel="stylesheet" href="site-lib/styles/obsidian.css"><link rel="preload" href="site-lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="site-lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="site-lib/styles/main-styles.css"></noscript><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-vertical-spacing:1.3em;--sidebar-margin:12px}:root{background-color:#202124}.sidebar{height:100%;font-size:14px;z-index:10;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));position:relative;overflow:hidden;overflow:clip;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}#left-sidebar{left:0}#right-sidebar{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}.sidebar.floating{position:absolute}.sidebar .leaf-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .leaf-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}#left-sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}#right-sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar #left-sidebar-content,.sidebar #right-sidebar-content{contain:none!important;container-type:normal!important;animation:none!important}.sidebar:has(.leaf-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:calc(2.3em + 2 * var(--sidebar-margin));width:var(--sidebar-width);padding:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}#left-sidebar .sidebar-topbar{left:0;flex-direction:row;border-top-right-radius:var(--radius-l)}#right-sidebar .sidebar-topbar{right:0;flex-direction:row-reverse;border-top-left-radius:var(--radius-l)}#left-sidebar .topbar-content{margin-right:calc(2.3em + var(--sidebar-margin));flex-direction:row}#right-sidebar .topbar-content{margin-left:calc(2.3em + var(--sidebar-margin));flex-direction:row-reverse}.topbar-content{overflow:hidden visible;overflow:clip visible;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:2px!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}#left-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}#right-sidebar .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.feature-title{margin-left:1px;text-transform:uppercase;letter-spacing:.06em;margin-top:.75em;margin-bottom:.75em}.feature-header{display:flex;align-items:center;padding-top:0;font-size:1em;padding-left:0}body.floating-sidebars .sidebar{position:absolute}body{transition:background-color var(--color-fade-speed) ease-in-out}#navbar:not(:empty){display:flex;align-items:center;justify-content:space-between;padding:.5em 1em;width:100%}#main{display:flex;flex-direction:column;height:100%;width:100%;align-items:stretch;justify-content:center}#main-horizontal{display:flex;flex-direction:row;flex-grow:1;width:100%;align-items:stretch;justify-content:center}#center-content{flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0!important;transition:opacity .2s ease-in-out;pointer-events:none}#center-content>.obsidian-document{padding-left:2em;padding-right:1em;margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}body #center-content>.obsidian-document>.markdown-preview-sizer{padding-bottom:80vh;width:100%;max-width:var(--line-width);flex-basis:var(--line-width);transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document>div{width:100%!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}#center-content>.obsidian-document:not([data-type=markdown]).embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}#center-content>.obsidian-document:not([data-type=markdown]).embed>*{max-width:100%;max-height:100%;object-fit:contain}:not(h1,h2,h3,h4,h5,h6,li):has(> :is(.math,table)){overflow-x:auto!important}#center-content>.obsidian-document:not([data-type=markdown]){overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.obsidian-document[data-type=attachment]{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;width:100%}.obsidian-document[data-type=attachment]>*{outline:0;border:none;box-shadow:none}.obsidian-document[data-type=attachment] :is(img){max-width:90%;max-height:90%;object-fit:contain}.obsidian-document[data-type=attachment]>:is(audio){width:100%;max-width:min(90%,var(--line-width))}.obsidian-document[data-type=attachment]>:is(embed,iframe,video){width:100%;height:100%;max-width:100%;max-height:100%;object-fit:contain}.canvas-wrapper>:is(.header,.footer){z-index:100;position:absolute;display:flex;justify-content:center;flex-direction:column;width:100%;align-items:center}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){let e=document.querySelectorAll("link[itemprop='include']");for(const t of e){let e=t.getAttribute("href");try{let o="";if(e.startsWith("https:")||e.startsWith("http:")||"file:"!=window.location.protocol){const n=await fetch(e);if(!n.ok){console.log("Could not include file: "+e),t?.remove();continue}o=await n.text()}else{const t=document.getElementById(btoa(encodeURI(e)));if(t){const e=JSON.parse(decodeURI(atob(t.getAttribute("value")??"")));o=e?.data??""}}let n=document.createRange().createContextualFragment(o);t.before(n),t.remove(),console.log("Included text: "+o),console.log("Included file: "+e)}catch(o){t?.remove(),console.log("Could not include file: "+e,o);continue}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script")));!function e(n){let l=o[n],c=n+1;l?(l&&"true"!=l.getAttribute("loaded")||n<o.length&&e(c),n<o.length&&l.addEventListener("load",(()=>e(c)))):n<o.length?e(c):t()}(0)}</script></head><body class="publish css-settings-manager styled-scrollbars show-inline-title show-ribbon is-focused"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="parsed-feature-container" style="display: contents;"><link itemprop="include" href="site-lib/html/custom-head-content-content.html"></div><div id="main"><div id="navbar"></div><div id="main-horizontal"><div id="left-content" class="leaf" style="--sidebar-width: var(--sidebar-width-left);"><div id="left-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><div id="search-container"><div id="search-wrapper"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div aria-label="Clear search" id="search-clear-button"></div></div></div></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="left-sidebar-content" class="leaf-content"><link itemprop="include" href="site-lib/html/file-tree-content.html"></div></div><script defer="">let ls = document.querySelector("#left-sidebar"); ls.classList.toggle("is-collapsed", window.innerWidth < 768); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div></div><div id="center-content" class="leaf"><div class="obsidian-document markdown-preview-view markdown-rendered node-insert-event is-readable-line-width allow-fold-headings allow-fold-lists show-indentation-guide show-properties" data-type="markdown"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><div class="header"><h1 class="page-title heading inline-title" id="Узлы_0">Узлы</h1><div class="data-bar"></div></div><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="el-p"><p dir="auto">Узлы в <a data-tooltip-position="top" aria-label="Дерево (граф) решений" data-href="Дерево (граф) решений" href="1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html" class="internal-link" target="_self" rel="noopener nofollow">дереве решений</a> обозначают отдельные шаги в задаваемом деревом алгоритме.<br>
В коде узлы представлены классами пакета <code>its.model.nodes</code>.</p></div><div class="el-p"><p dir="auto">Узлы могут содержать <a data-tooltip-position="top" aria-label="Выражения" data-href="Выражения" href="1.-модели-(its_domainmodel)/дерево-решений/выражения.html" class="internal-link" target="_self" rel="noopener nofollow">выражения</a> для обозначения более низкоуровневой логики взаимодействия с данными.<br>
В аналогии с обычными языками программирования узлы соответствуют statement-ам, а выражения - expression-ам. </p></div><div class="el-h2"><h2 data-heading="Ветви мысли, ThoughtBranch" dir="auto" class="heading" id="Ветви_мысли,_ThoughtBranch_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Ветви мысли, ThoughtBranch</h2></div><div class="el-p"><p dir="auto">Если не углубляться в отдельные узлы дерева решений, в нем можно выделить отдельные <strong>ветви мысли</strong>. Сами по себе ветви представляют некоторую логически завершенную часть полного алгоритма, и отвечают на какой-то конкретный вопрос.<br>
В аналогии с обычными языками программирования ветви мысли соответствуют отдельным функциям/процедурам.</p></div><div class="el-p"><p dir="auto">В коде ветви мысли представлены классом <code>ThoughtBranch</code>, и имеют ссылку на узел, представляющий их начало - <code>ThoughtBranch.start</code>.</p></div><div class="el-h2"><h2 data-heading="Результаты ветвей мысли" dir="auto" class="heading" id="Результаты_ветвей_мысли_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Результаты ветвей мысли</h2></div><div class="el-p"><p dir="auto">Аналогично любой функции, <strong>ветвь мысли должна выдавать результат</strong> - ответ на соответствующий ей вопрос. В этом смысле все дерево является одной большой ветвью мысли (которое зачастую разделяется на более мелкие) - поскольку выдает ответ на основной вопрос задачи.<br>
По результату своего выполнения, ветви мысли <strong>могут иметь следующие результаты,</strong> представленные в коде перечислением <code>BranchResult</code></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Правильно/верно/true (<code>BranchResult.CORRECT</code>) - с точки зрения данной ветви все выполнено правильно, ответ на вопрос ветви "Да".</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Неправильно/ошибка/false (<code>BranchResult.ERROR</code>) - с точки зрения данной ветви была допущена ошибка, ответ на вопрос ветви "Нет".</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Неизвестно/невозможно определить корректность/null (<code>BranchResult.NULL</code>) - данная ветвь не смогла выдать определенный ответ; либо ситуация слишком неожиданная, либо ветвь решает "передать управление" далее по дереву.</li>
</ul></div><div class="el-p"><p dir="auto">Выдаваемый ветвью результат определяется в последнем узле, в который пришло его выполнение. В коде классы узлов, которые могут так выдавать результаты, реализовывают интерфейс <code>EndingNode</code> - это либо узлы результатов, либо узлы агрегации.</p></div><div class="el-h3"><h3 data-heading="Узлы результатов, BranchResultNode" dir="auto" class="heading" id="Узлы_результатов,_BranchResultNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Узлы результатов, BranchResultNode</h3></div><div class="el-p"><p dir="auto">Узлы результатов представляют собой основной способ завершить ветвь мысли и вернуть из нее какой-то результат.<br>
<span alt="nodes_BranchResultNode.png" src="images/nodes_branchresultnode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_BranchResultNode.png" src="images/nodes_branchresultnode.png" target="_self"></span><br>
В коде они представлены классом <code>BranchResultNode</code>, и содержат следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><code>BranchResultNode.value</code> - <strong>результат, возвращаемый узлом</strong>.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>BranchResultNode.actionExpr</code> (может отсутствовать) - <strong>выражение, задающее действие, которое необходимо выполнить по достижении этого узла</strong>.</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Если оно есть, то выполняется выражение <code>BranchResultNode.actionExpr</code></li>
<li data-line="1" dir="auto">Текущая ветвь мысли считается завершенной с результатом <code>BranchResultNode.value</code>.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Выражение <code>BranchResultNode.actionExpr</code> должно быть валидным, и соответствовать известной в дереве на данный момент информации.</li>
</ul></div><div class="el-h2"><h2 data-heading="Связующие узлы и переходы между узлами" dir="auto" class="heading" id="Связующие_узлы_и_переходы_между_узлами_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Связующие узлы и переходы между узлами</h2></div><div class="el-p"><p dir="auto">Основное множество узлов, имеющих собственную внутреннюю логику, называются "связующими", поскольку предполагают переход к другим узлам (а то есть связь с ними).<br>
В коде такие узлы наследуются от класса <code>LinkNode</code>.</p></div><div class="el-p"><p dir="auto">Основной отличительной чертой таких узлов является <strong>набор переходов</strong>, представленный в коде полем <code>LinkNode.outcomes</code>. Данное поле имеет тип <code>Outcomes</code>, и по сути представляет собой соответствие ключа перехода и узла, к которому должен быть совершен переход. Данное соответствие представлено коллекцией единичных переходов (объектов класса <code>Outcome</code>), каждый из которых хранит соответствующие ключ <code>Outcome.key</code> и узел <code>Outcome.node</code>.<br>
В процессе прорешивания из узла <strong>совершается тот переход, чей ключ соответствует ответу узла</strong> (тип этого ответа и ключей переходов зависит от конкретной специфики узла).</p></div><div class="el-p"><p dir="auto">Стоит отметить, что каждый отдельный переход <code>Outcome</code> в контейнере <code>Outcomes</code> наследуется от класса <code>DecisionTreeElement</code>, а значит может иметь метаданные. Это бывает полезно, поскольку бывают случаи привязки метаданных не к узлу в общем, а к конкретному переходу из него.</p></div><div class="el-h2"><h2 data-heading="Вопросы" dir="auto" class="heading" id="Вопросы_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Вопросы</h2></div><div class="el-p"><p dir="auto">Большинство узлов в типичном дереве решений является узлами вопросов. Данные узлы представляют собой необходимость выполнить некоторые рассуждения над ситуацией (задаться некоторым вопросом), и в зависимости от результата этих рассуждений (ответа на вопрос) совершить переход к различным следующим узлам.</p></div><div class="el-h3"><h3 data-heading="Обычный вопрос, QuestionNode" dir="auto" class="heading" id="Обычный_вопрос,_QuestionNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Обычный вопрос, QuestionNode</h3></div><div class="el-p"><p dir="auto"><span alt="nodes_QuestionNode.png" src="images/nodes_questionnode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_QuestionNode.png" src="images/nodes_questionnode.png" target="_self"></span><br>
Обычный узел вопроса представлен классом <code>QuestionNode</code>, и содержит следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><code>QuestionNode.expr</code> - <strong>выражение, представляющее рассуждения (вопрос) в этом узле</strong></li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>QuestionNode.outcomes</code> (наследуется от <code>LinkNode</code>) - <strong>переходы к следующим узлам</strong>; ключом перехода является результат выражения <code>QuestionNode.expr</code>.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><code>QuestionNode.trivialityExpr</code> (может отсутствовать и в большинстве случаев отсутствует) -  <strong>предикат тривиальности</strong>: булево выражение, возвращающее true, если узел должен считаться тривиальным. Тривиальные узлы считаются очевидными, и на них не должно заостряться внимание пользователя. При прорешивании тривиальность напрямую не используется, а является вспомогательной информацией для сторонних проектов.</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span><code>QuestionNode.isSwitch</code> (может отсутствовать и в большинстве случаев отсутствует) - <strong>флаг, означающий, что узел это тривиальная развилка</strong> ("switch"). Аналогично <code>QuestionNode.trivialityExpr</code>, но константа.</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Вычисляется выражение <code>QuestionNode.expr</code></li>
<li data-line="1" dir="auto"><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Среди переходов <code>QuestionNode.outcomes</code> находится тот, чей ключ соответствует результату вычисления выражения
<ul class="has-list-bullet">
<li data-line="2" dir="auto"><span class="list-bullet"></span>Если такого нет, то выкидывается ошибка</li>
</ul>
</li>
<li data-line="3" dir="auto">Решение переходит к узлу, соответствующему найденному переходу.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Вложенные выражения должны быть валидными, и соответствовать известной в дереве на данный момент информации.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Типы ключей всех переходов <code>QuestionNode.outcomes</code> должны соответствовать типу возвращаемого значения выражения <code>QuestionNode.expr</code></li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Тип возвращаемого значения выражения <code>QuestionNode.trivialityExpr</code> должен быть булевым значением.</li>
</ul></div><div class="el-h3"><h3 data-heading="Вопрос с кортежем (с несколькими частями), TupleQuestionNode" dir="auto" class="heading" id="Вопрос_с_кортежем_(с_несколькими_частями),_TupleQuestionNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Вопрос с кортежем (с несколькими частями), TupleQuestionNode</h3></div><div class="el-p"><p dir="auto"><span alt="nodes_TupleQuestionNode.png" src="images/nodes_tuplequestionnode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_TupleQuestionNode.png" src="images/nodes_tuplequestionnode.png" target="_self"></span><br>
Узел вопроса с кортежем или вопроса с несколькими частями отличается от обычного тем, что <strong>совершает несколько проверок одновременно, и совершает переход в зависимости от комбинаций ответов на них</strong>.</p></div><div class="el-p"><p dir="auto">Узел вопроса с кортежем представлен классом <code>TupleQuestionNode</code>, и содержит следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>TupleQuestionNode.parts</code> - <strong>список отдельных частей данного вопроса</strong>. Каждая такая часть представлена классом <code>TupleQuestionPart</code> и содержит следующую информацию:
<ul class="has-list-bullet">
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>TupleQuestionPart.expr</code> -  <strong>выражение, представляющее рассуждения (вопрос) в этой части узла</strong></li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><code>TupleQuestionPart.possibleOutcomes</code> - <strong>вспомогательный список ожидаемых результатов</strong> вычисления выражения  <code>TupleQuestionPart.expr</code>. При прорешивании напрямую не используются, а являются вспомогательной информацией для сторонних проектов.</li>
</ul>
</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span><code>TupleQuestionNode.outcomes</code> (наследуется от <code>LinkNode</code>) - <strong>переходы к следующим узлам</strong>; ключом перехода является объект <code>ValueTuple</code> - кортеж значений, составляемый из результатов вычислений выражений <code>TupleQuestionPart.expr</code> всех частей <code>TupleQuestionNode.parts</code> данного узла.</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Для всех частей <code>TupleQuestionNode.parts</code> вычисляется их выражение <code>TupleQuestionPart.expr</code></li>
<li data-line="1" dir="auto">Из полученных результатов составляется кортеж <code>ValueTuple</code></li>
<li data-line="2" dir="auto"><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Среди переходов <code>TupleQuestionPart.outcomes</code> находится тот, чей ключ (кортеж) соответствует полученному на предыдущем шаге кортежу результатов
<ul class="has-list-bullet">
<li data-line="3" dir="auto"><span class="list-bullet"></span>Если такого нет, то выкидывается ошибка</li>
</ul>
</li>
<li data-line="4" dir="auto">Решение переходит к узлу, соответствующему найденному переходу.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>В узле должно быть как минимум две части <code>TupleQuestionNode.parts</code> (иначе нужно использовать  <code>QuestionNode</code>)</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Для каждой части <code>TupleQuestionNode.parts</code>:
<ul class="has-list-bullet">
<li data-line="2" dir="auto"><span class="list-bullet"></span>Вложенные выражения должны быть валидными, и соответствовать известной в дереве на данный момент информации.</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>Типы ожидаемых результатов <code>TupleQuestionPart.possibleOutcomes</code> должны соответствовать типу возвращаемого значения выражения <code>TupleQuestionPart.expr</code></li>
</ul>
</li>
<li data-line="4" dir="auto"><span class="list-bullet"></span>Ключи всех переходов <code>TupleQuestionPart.outcomes</code> должны быть кортежами <code>ValueTuple</code>, а также количество и типы значений в этих кортежах должны соответствовать количеству и типу выражений в частях узла.</li>
</ul></div><div class="el-h2"><h2 data-heading="Действия" dir="auto" class="heading" id="Действия_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Действия</h2></div><div class="el-p"><p dir="auto"><strong>Узлы действий представляют собой некоторую манипуляцию с данными о задаче</strong> - необходимо либо изменить ситуацию, либо получить и запомнить некоторую информацию.</p></div><div class="el-h3"><h3 data-heading="Действие поиска (найти объект и запомнить), FindActionNode" dir="auto" class="heading" id="Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Действие поиска (найти объект и запомнить), FindActionNode</h3></div><div class="el-p"><p dir="auto"><span alt="nodes_FindActionNode.png" src="images/nodes_findactionnode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_FindActionNode.png" src="images/nodes_findactionnode.png" target="_self"></span><br>
Узел действия поиска по своей сути аналогичен оператору присвоения в обычном языке программирования - <strong>он получает (находит) некоторый объект, и запоминает его как некоторую переменную дерева мысли.</strong><br>
<strong>Данная переменная впоследствии доступна из всех выражений в узлах этой ветви мысли</strong> (но не за пределами этой ветви мысли).</p></div><div class="el-p"><p dir="auto">Узел действия поиска представлен классом <code>FindActionNode</code>, и содержит следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>FindActionNode.varAssignment</code> - <strong>основное объявление/присвоение переменной</strong>. Имеет тип <code>DecisionTreeVarAssignment</code>, содержащий следующую информацию:
<ul class="has-list-bullet">
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>DecisionTreeVarAssignment.variable</code> - информация о переменной. Содержит тип (<code>TypedVariable.className</code>) и имя (<code>TypedVariable.varName</code>) переменной.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><code>DecisionTreeVarAssignment.valueExpr</code> - выражение для вычисления значения переменной. Должно вернуть объект.</li>
</ul>
</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span><code>FindActionNode.errorCategories</code> - <strong>вспомогательный список категорий ошибок</strong>. При прорешивании напрямую не используются, а являются вспомогательной информацией для сторонних проектов. Каждая категория ошибок имеет тип <code>FindErrorCategory</code>, и содержит следующую информацию:
<ul class="has-list-bullet">
<li data-line="4" dir="auto"><span class="list-bullet"></span><code>FindErrorCategory.priority</code> - <strong>приоритет данной категории ошибок</strong>. Eсли объект соответствует нескольким категориям,  то будет выбрана категория с наивысшим приоритетом (1 считается наивысшим приоритетом, и далее 2, 3.. по убыванию)</li>
<li data-line="5" dir="auto"><span class="list-bullet"></span><code>FindErrorCategory.selectorExpr</code> -  <strong>выражение предикат поиска</strong>: булево выражение, которое должно вернуть true, если объект соответствует данной категории ошибки. Проверяемый объект в данном выражении представлен контекстной переменной с именем "checked".</li>
</ul>
</li>
<li data-line="6" dir="auto"><span class="list-bullet"></span><code>FindActionNode.secondaryAssignments</code> - т.н. <strong>"вторичные" объявления/присвоения переменных</strong>. Представляют собой список присвоений <code>DecisionTreeVarAssignment</code> (данный класс уже был описан выше). Данные присвоения выполняются только в случае, если основное  <code>FindActionNode.varAssignment</code> было успешно выполнено. Также, во вторичных присвоениях также можно ссылаться на основную переменную узла. Таким образом, вторичные присвоения можно использовать, если в одном узле необходимо объявить сразу несколько связанных переменных. При этом предполагается, что внимание студента заостряется только на основном присвоении. </li>
<li data-line="7" dir="auto"><span class="list-bullet"></span><code>FindActionNode.outcomes</code> (наследуется от <code>LinkNode</code>) - <strong>переходы к следующим узлам</strong>; ключом перехода является булево значение - true, если основное присвоение успешно выполнено (объект найден), false в противном случае. Переход с ключом false может отсутствовать, если предполагается, что объект всегда будет найден; переход с ключом true должен быть обязательно. </li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Для основного присвоения <code>FindActionNode.varAssignment</code> вычисляется выражение <code>DecisionTreeVarAssignment.valueExpr</code></li>
<li data-line="1" dir="auto">Если значение основного присвоения не было найдено, то решение переходит к узлу, соответствующему переходу с ключом false</li>
<li data-line="2" dir="auto">Если значение основного присвоения было найдено, то данный объект-значение запоминается в переменную дерева, соответствующую описанию переменной <code>DecisionTreeVarAssignment.variable</code> в основном присвоении <code>FindActionNode.varAssignment</code></li>
<li data-line="3" dir="auto"><span class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Аналогично основному присвоению выполняются все вторичные присвоения <code>FindActionNode.secondaryAssignments</code>: вычисляются объекты-значения, запоминаются переменные
<ul class="has-list-bullet">
<li data-line="4" dir="auto"><span class="list-bullet"></span>Если на данном этапе какое-либо из вторичных присвоений не удается (объект-значение не найден), то выкидывается ошибка - предполагается, что такая ситуация невозможна.</li>
</ul>
</li>
<li data-line="5" dir="auto">Решение переходит к узлу, соответствующему переходу с ключом true. Здесь и далее в этой ветви мысли переменные, объявленные в узле поиска, доступны в виде переменных дерева.  </li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Вложенные выражения должны быть валидными и соответствовать известной в дереве на данный момент информации.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Выражения в присвоениях <code>FindActionNode.varAssignment</code> и <code>FindActionNode.secondaryAssignments</code> должны иметь возвращаемый тип Объект, соответствующий классу, заявленному для соответствующей переменной.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Тип возвращаемого значения выражений в <code>FindActionNode.errorCategories</code> должен быть булевым значением </li>
<li data-line="3" dir="auto"><span class="list-bullet"></span>Ключи всех переходов <code>FindActionNode.outcomes</code> должны быть булевыми значениями; переход с ключом true должен быть обязательно. </li>
</ul></div><div class="el-h3"><h3 data-heading="Другие действия" dir="auto" class="heading" id="Другие_действия_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Другие действия</h3></div><div class="el-div"><div data-callout-metadata="" data-callout-fold="" data-callout="note" class="callout"><div class="callout-title" dir="auto"><div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"></path><path d="m15 5 4 4"></path></svg></div><div class="callout-title-inner">Note</div></div><div class="callout-content">
<p dir="auto">На данный момент действие поиска - единственный узел действий в системе, поскольку до сих пор не возникало необходимости выполнять какие-то еще другие действия в "середине" решения.<br>
Однако весьма вероятно, что в какой-то момент также понадобится узел выполнения произвольных выражений над операцией. На данный момент такие действия возможны только в рамках узлов результатов <code>BranchResultNode</code> - но они, закономерно, могут выполняться только в конце конкретной ветви мысли.</p>
</div></div></div><div class="el-h2"><h2 data-heading="Агрегация и узлы агрегации" dir="auto" class="heading" id="Агрегация_и_узлы_агрегации_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Агрегация и узлы агрегации</h2></div><div class="el-p"><p dir="auto">Аналогично же функциям, <strong>более высокоуровневые ветви мысли могут "вызывать" более низкоуровневые</strong>. Это происходит в случаях, если для определения ответа на вопрос высокоуровневой ветви нужны некие отдельные ответы на более низкоуровневые вопросы.</p></div><div class="el-p"><p dir="auto">На данный момент в проекте выделено 4 вида агрегации (5, если считать последовательность). В коде эти виды представлены перечислением <code>AggregationMethod</code>. Рассмотрим их:</p></div><div class="el-p"><p dir="auto"><strong>Независимые проверки по логическому И, SIM:AND</strong><br>
<em>SIM от слова SIMultaneous, одновременно</em><br>
<span alt="nodes_sim_and.png" src="images/nodes_sim_and.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_sim_and.png" src="images/nodes_sim_and.png" target="_self"></span><br>
Применяется, когда необходимо сделать несколько проверок независимо друг от друга и отобразить их результат. При этом любая ошибка во вложенных ветвях приводит к ошибке в основной ветви.<br>
Результат для основной ветви вычисляется так:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">null, если все ветви такие</li>
<li data-line="1" dir="auto">true, если все ветви либо true либо null</li>
<li data-line="2" dir="auto">false иначе<br>
При этом, из узла агрегации по SIM:AND всегда должен быть переход по true результату, т.к. в этом случае решение продолжается.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Независимые проверки по логическому ИЛИ, SIM:OR</strong><br>
<span alt="nodes_sim_or.png" src="images/nodes_sim_or.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_sim_or.png" src="images/nodes_sim_or.png" target="_self"></span><br>
Применяется, когда необходимо сделать несколько проверок независимо друг от друга и отобразить их результат. При этом, если хотя бы одна из вложенных ветвей выполнена корректно, то и основная ветвь считается выполненной корректно.<br>
Результат для основной ветви вычисляется так:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">null, если все ветви такие</li>
<li data-line="1" dir="auto">true, если хотя бы одна ветвь true</li>
<li data-line="2" dir="auto">false иначе<br>
При этом, из узла агрегации по SIM:OR всегда должны быть переходы по false и null результатам, т.к. эти случаи возникают только при рассмотрении всех ветвей вместе, поэтому рассматривать данные результаты нужно на верхнем уровне.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Взаимоисключающие проверки, MUTEX</strong><br>
<em>MUTEX от слов MUTually EXclusive, взаимно исключающий</em><br>
<span alt="nodes_mutex.png" src="images/nodes_mutex.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_mutex.png" src="images/nodes_mutex.png" target="_self"></span><br>
Применяется, когда необходимо сделать несколько проверок независимо друг от друга и отобразить результат одной из них - предполагается, что в любой ситуации только одна из данных проверок даст какой-либо определенный результат (true либо false), а все остальные выдадут неопределенность (null).<br>
Результат для основной ветви вычисляется так:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Если среди ветвей есть результат true или false, то берется он</li>
<li data-line="1" dir="auto">null иначе<br>
Обязательных переходов из узла агрегации по MUTEX нет, но чаще всего из него реализуется переход по null - "Если не выполнилось ничего из перечисленного то переходить сюда".</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Гипотезы, HYP</strong><br>
<em>HYP от слова HYPothesis, гипотеза</em><br>
<span alt="nodes_hyp.png" src="images/nodes_hyp.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_hyp.png" src="images/nodes_hyp.png" target="_self"></span><br>
Применяется, когда системе необходимо делать предположения (гипотезы) о том, как мог бы рассуждать обучаемый, чтобы прийти к своему ответу, потому что сам ответ не дает однозначной информации для этого.<br>
Результат для основной ветви вычисляется так:</p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">true, если хотя бы одна ветвь true</li>
<li data-line="1" dir="auto">false, если хотя бы одна ветвь false</li>
<li data-line="2" dir="auto">null иначе<br>
При этом, из узла агрегации по HYP всегда должны быть переходы по null результату, т.к. этот случай может возникнуть только при рассмотрении всех ветвей вместе, поэтому рассматривать его нужно на верхнем уровне.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Последовательность, SEQ</strong><br>
<em>SEQ от слова SEQuence, последовательность</em><br>
<span alt="nodes_seq.png" src="images/nodes_seq.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_seq.png" src="images/nodes_seq.png" target="_self"></span><br>
Последовательность является особым видом агрегации, который на первый взгляд может даже не казаться агрегацией. Он применяется, когда необходимо последовательно выполнить несколько проверок и вернуть первый определенный (true или false) результат.</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Учитывая эту формулировку, технически можно сказать, что большинство узлов в дереве объединяются агрегацией SEQ, поскольку идут последовательно друг за другом, и выполнение завершается на первом встреченном результате.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>В то же время, агрегацию SEQ по ветвям нельзя реализовать аналогично остальным типам агрегации, поскольку он требует задания некоторого порядка, в котором проверяются ветви. <em>Подробнее об этом см. <a data-tooltip-position="top" aria-label="Узел последовательной агрегации, WhileCycleNode" data-href="#Узел последовательной агрегации, WhileCycleNode" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_последовательной_агрегации,_WhileCycleNode_0" class="internal-link" target="_self" rel="noopener nofollow">WhileCycleNode</a>.</em> В связи с этим, SEQ отсутствует в перечислении <code>AggregationMethod</code>.<br>
Результат для основной ветви вычисляется так:</li>
</ul></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Берется результат первой из ветвей, чей результат не null (true или false); последующие ветви не выполняются.</li>
<li data-line="1" dir="auto">Если все ветви выдали null, то null<br>
При этом, из узла агрегации по SEQ всегда должны быть переходы по null результату, т.к. именно в нем необходимо определить действия, выполняемые после завершения последовательности.</li>
</ol></div><div class="el-h3"><h3 data-heading="Узел агрегации по ветвям, BranchAggregationNode" dir="auto" class="heading" id="Узел_агрегации_по_ветвям,_BranchAggregationNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Узел агрегации по ветвям, BranchAggregationNode</h3></div><div class="el-p"><p dir="auto"><span alt="nodes_BranchAggregationNode.png" src="images/nodes_branchaggregationnode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_BranchAggregationNode.png" src="images/nodes_branchaggregationnode.png" target="_self"></span><br>
Узел агрегации по ветвям предполагает агрегацию нескольких различных (непохожих друг на друга) проверок, представленных несколькими отдельными ветвями мысли. Это одна из двух основных форм агрегации, вторая - <a data-tooltip-position="top" aria-label="Узел агрегации в цикле по объектам, CycleAggregationNode" data-href="#Узел агрегации в цикле по объектам, CycleAggregationNode" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0" class="internal-link" target="_self" rel="noopener nofollow">CycleAggregationNode</a></p></div><div class="el-p"><p dir="auto">В коде данный узел представлен классом <code>BranchAggregationNode</code> и содержит следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><code>BranchAggregationNode.aggregationMethod</code> - <strong>метод агрегации результатов ветвей</strong> в данном узле.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>BranchAggregationNode.thoughtBranches</code> - <strong>список агрегируемых ветвей мысли</strong>.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><code>BranchAggregationNode.outcomes</code> (наследуется от <code>LinkNode</code>) - <strong>переходы к следующим узлам</strong>; ключом перехода является результат агрегации вложенных ветвей <code>BranchResult</code>.</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Выполняются все вложенные ветви мысли <code>BranchAggregationNode.thoughtBranches</code>, их результаты запоминаются</li>
<li data-line="1" dir="auto">На основе метода агрегации <code>BranchAggregationNode.aggregationMethod</code> в данном узле, а также результатов вложенных ветвей, вычисляется результат <code>BranchResult</code> данного узла.</li>
<li data-line="2" dir="auto">Если у данного узла есть переход с ключом, соответствующим полученному результату, то решение переходит к узлу, соответствующему данному переходу. Иначе текущая ветвь мысли считается завершенной с результатом, соответствующим полученному.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Список агрегируемых ветвей <code>BranchAggregationNode.thoughtBranches</code> не должен быть пустым.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Переходы из узла должны содержать переходы с обязательными ключами, соответствующими виду агрегации.  </li>
</ul></div><div class="el-h3"><h3 data-heading="Узел агрегации в цикле по объектам, CycleAggregationNode" dir="auto" class="heading" id="Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Узел агрегации в цикле по объектам, CycleAggregationNode</h3></div><div class="el-p"><p dir="auto"><span alt="nodes_CycleAggregationNode.png" src="images/nodes_cycleaggregationnode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_CycleAggregationNode.png" src="images/nodes_cycleaggregationnode.png" target="_self"></span><br>
Узел агрегации в цикле по объектам предполагает агрегацию нескольких однотипных проверок, применяющихся к нескольким объектам в задаче. Это вторая из двух основных форм агрегации, первая - <a data-tooltip-position="top" aria-label="Узел агрегации по ветвям, BranchAggregationNode" data-href="#Узел агрегации по ветвям, BranchAggregationNode" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_по_ветвям,_BranchAggregationNode_0" class="internal-link" target="_self" rel="noopener nofollow">BranchAggregationNode</a>.</p></div><div class="el-p"><p dir="auto">В коде данный узел представлен классом <code>CycleAggregationNode</code> и содержит следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><code>CycleAggregationNode.aggregationMethod</code> - <strong>метод агрегации результатов ветвей</strong> в данном узле.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>CycleAggregationNode.thoughtBranch</code> - <strong>ветвь мысли, представляющая тело цикла</strong>.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><code>CycleAggregationNode.variable</code> - <strong>переменная перебора цикла</strong>. Данная переменная доступна как <strong>переменная дерева</strong> в теле цикла (но не вне его).</li>
<li data-line="3" dir="auto"><span class="list-bullet"></span><code>CycleAggregationNode.selectorExpr</code> - <strong>выражение предикат поиска</strong>: булево выражение, которое должно вернуть true для всех объектов, которые должны перебираться в цикле;  проверяемый объект подставляется в предикат как <strong>контекстная переменная</strong> с именем и типом соответствующими переменной <code>CycleAggregationNode.variable</code></li>
<li data-line="4" dir="auto"><span class="list-bullet"></span><code>CycleAggregationNode.errorCategories</code> - <strong>вспомогательный список категорий ошибок</strong>. При прорешивании напрямую не используются, а являются вспомогательной информацией для сторонних проектов. Каждая категория ошибок имеет тип <code>FindErrorCategory</code>, который был подробно описан в <a data-tooltip-position="top" aria-label="Действие поиска (найти объект и запомнить), FindActionNode" data-href="#Действие поиска (найти объект и запомнить), FindActionNode" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0" class="internal-link" target="_self" rel="noopener nofollow">разделе о FindActionNode</a></li>
<li data-line="5" dir="auto"><span class="list-bullet"></span><code>CycleAggregationNode.outcomes</code> (наследуется от <code>LinkNode</code>) - <strong>переходы к следующим узлам</strong>; ключом перехода является результат агрегации вложенных ветвей <code>BranchResult</code>.</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Перебираются объекты типа, объявленного для переменной цикла <code>CycleAggregationNode.variable</code>. Из них оставляются те, для которых предикат поиска <code>CycleAggregationNode.selectorExpr</code> выдает true </li>
<li data-line="1" dir="auto">Для каждого найденного объекта выполняется тело цикла <code>CycleAggregationNode.thoughtBranch</code>, результаты каждой итерации запоминаются. В теле цикла соответствующий объект доступен как переменная дерева с именем и типом, соответствующим переменной цикла <code>CycleAggregationNode.variable</code>.</li>
<li data-line="2" dir="auto">На основе метода агрегации <code>CycleAggregationNode.aggregationMethod</code> в данном узле, а также результатов итераций для объектов, вычисляется результат <code>BranchResult</code> данного узла.</li>
<li data-line="3" dir="auto">Если у данного узла есть переход с ключом, соответствующим полученному результату, то решение переходит к узлу, соответствующему данному переходу. Иначе текущая ветвь мысли считается завершенной с результатом, соответствующим полученному.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Вложенные выражения должны быть валидными и соответствовать известной в дереве на данный момент информации.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Тип возвращаемого значения выражения предиката поиска <code>CycleAggregationNode.selectorExpr</code>, а также выражений в <code>CycleAggregationNode.errorCategories</code> должен быть булевым значением </li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Переходы из узла должны содержать переходы с обязательными ключами, соответствующими виду агрегации.  </li>
</ul></div><div class="el-h3"><h3 data-heading="Узел последовательной агрегации, WhileCycleNode" dir="auto" class="heading" id="Узел_последовательной_агрегации,_WhileCycleNode_0"><span class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></span>Узел последовательной агрегации, WhileCycleNode</h3></div><div class="el-p"><p dir="auto"><span alt="nodes_WhileCycleNode.png" src="images/nodes_whilecyclenode.png" class="internal-embed media-embed image-embed is-loaded" target="_self"><img alt="nodes_WhileCycleNode.png" src="images/nodes_whilecyclenode.png" target="_self"></span><br>
Узел последовательной агрегации по сути аналогичен обычному циклу "while" в языках программирования. Поскольку агрегацию по SEQ невозможно выполнить в узлах агрегации по ветвям или по объектам, она вынесена в данный узел.<br>
Данный узел во многом похож на цикл по объектам, но выполняет свое тело, пока выполняется некоторое условие, или пока не найден определенный (true или false) результат. Предполагается, что результат условия будет меняться из-за <a data-tooltip-position="top" aria-label="Узлы результатов, BranchResultNode" data-href="#Узлы результатов, BranchResultNode" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узлы_результатов,_BranchResultNode_0" class="internal-link" target="_self" rel="noopener nofollow">доп. действий в неопределенных узлах-результатах</a> внутри тела цикла.</p></div><div class="el-p"><p dir="auto">В коде данный узел представлен классом <code>WhileCycleNode</code>, и содержит следующую информацию:</p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span><code>WhileCycleNode.conditionExpr</code> - <strong>выражение условия</strong>: булево выражение, которое должно выдавать true, если цикл должен продолжаться. </li>
<li data-line="1" dir="auto"><span class="list-bullet"></span><code>WhileCycleNode.thoughtBranch</code> - <strong>ветвь мысли, представляющая тело цикла</strong>.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span><code>WhileCycleNode.outcomes</code> (наследуется от <code>LinkNode</code>) - <strong>переходы к следующим узлам</strong>; ключом перехода является результат агрегации вложенных ветвей <code>BranchResult</code>.</li>
</ul></div><div class="el-p"><p dir="auto"><strong>Поведение при прорешивании:</strong></p></div><div class="el-ol"><ol>
<li data-line="0" dir="auto">Пока выполяется условие цикла <code>WhileCycleNode.conditionExpr</code>, выполняется тело цикла <code>WhileCycleNode.thoughtBranch</code>.</li>
<li data-line="1" dir="auto">Если очередная итерация завершилась с результатом true или false, то этот результат считается итоговым, и цикл завершается. Иначе если <code>WhileCycleNode.conditionExpr</code> не выполняется (выдает false), то цикл считается завершенным с результатом null.</li>
<li data-line="2" dir="auto">Если у данного узла есть переход с ключом, соответствующим полученному результату, то решение переходит к узлу, соответствующему данному переходу. Иначе текущая ветвь мысли считается завершенной с результатом, соответствующим полученному.</li>
</ol></div><div class="el-p"><p dir="auto"><strong>Валидация:</strong></p></div><div class="el-ul"><ul class="has-list-bullet">
<li data-line="0" dir="auto"><span class="list-bullet"></span>Вложенные выражения должны быть валидными и соответствовать известной в дереве на данный момент информации.</li>
<li data-line="1" dir="auto"><span class="list-bullet"></span>Тип возвращаемого значения выражения условия цикла <code>WhileCycleNode.conditionExpr</code>  должен быть булевым значением.</li>
<li data-line="2" dir="auto"><span class="list-bullet"></span>Переходы из узла должен содержать переход с ключом null.  </li>
</ul></div><div class="footer"><div class="data-bar"></div></div></div></div></div><div id="right-content" class="leaf" style="--sidebar-width: var(--sidebar-width-right);"><div id="right-sidebar" class="sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme-toggle-input" id=""><input class="theme-toggle-input" type="checkbox" id="theme-toggle-input"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content-wrapper"><div id="right-sidebar-content" class="leaf-content"><div id="outline" class=" tree-container"><div class="feature-header"><div class="feature-title">Table Of Contents</div><button class="clickable-icon nav-action-button tree-collapse-all" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-item mod-collapsible" data-depth="1"><a class="tree-item-self is-clickable mod-collapsible" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узлы_0" data-path="#Узлы_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="Узлы">Узлы</div></a><div class="tree-item-children"><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Ветви_мысли,_ThoughtBranch_0" data-path="#Ветви_мысли,_ThoughtBranch_0"><div class="tree-item-inner heading-link" heading-name="Ветви мысли, ThoughtBranch">Ветви мысли, ThoughtBranch</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Результаты_ветвей_мысли_0" data-path="#Результаты_ветвей_мысли_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="Результаты ветвей мысли">Результаты ветвей мысли</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узлы_результатов,_BranchResultNode_0" data-path="#Узлы_результатов,_BranchResultNode_0"><div class="tree-item-inner heading-link" heading-name="Узлы результатов, BranchResultNode">Узлы результатов, BranchResultNode</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item" data-depth="2"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Связующие_узлы_и_переходы_между_узлами_0" data-path="#Связующие_узлы_и_переходы_между_узлами_0"><div class="tree-item-inner heading-link" heading-name="Связующие узлы и переходы между узлами">Связующие узлы и переходы между узлами</div></a><div class="tree-item-children"></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Вопросы_0" data-path="#Вопросы_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="Вопросы">Вопросы</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Обычный_вопрос,_QuestionNode_0" data-path="#Обычный_вопрос,_QuestionNode_0"><div class="tree-item-inner heading-link" heading-name="Обычный вопрос, QuestionNode">Обычный вопрос, QuestionNode</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Вопрос_с_кортежем_(с_несколькими_частями),_TupleQuestionNode_0" data-path="#Вопрос_с_кортежем_(с_несколькими_частями),_TupleQuestionNode_0"><div class="tree-item-inner heading-link" heading-name="Вопрос с кортежем (с несколькими частями), TupleQuestionNode">Вопрос с кортежем (с несколькими частями), TupleQuestionNode</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Действия_0" data-path="#Действия_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="Действия">Действия</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0" data-path="#Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0"><div class="tree-item-inner heading-link" heading-name="Действие поиска (найти объект и запомнить), FindActionNode">Действие поиска (найти объект и запомнить), FindActionNode</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Другие_действия_0" data-path="#Другие_действия_0"><div class="tree-item-inner heading-link" heading-name="Другие действия">Другие действия</div></a><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-collapsible" data-depth="2"><a class="tree-item-self is-clickable mod-collapsible" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Агрегация_и_узлы_агрегации_0" data-path="#Агрегация_и_узлы_агрегации_0"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><div class="tree-item-inner heading-link" heading-name="Агрегация и узлы агрегации">Агрегация и узлы агрегации</div></a><div class="tree-item-children"><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_по_ветвям,_BranchAggregationNode_0" data-path="#Узел_агрегации_по_ветвям,_BranchAggregationNode_0"><div class="tree-item-inner heading-link" heading-name="Узел агрегации по ветвям, BranchAggregationNode">Узел агрегации по ветвям, BranchAggregationNode</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0" data-path="#Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0"><div class="tree-item-inner heading-link" heading-name="Узел агрегации в цикле по объектам, CycleAggregationNode">Узел агрегации в цикле по объектам, CycleAggregationNode</div></a><div class="tree-item-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-item-self is-clickable" href="1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_последовательной_агрегации,_WhileCycleNode_0" data-path="#Узел_последовательной_агрегации,_WhileCycleNode_0"><div class="tree-item-inner heading-link" heading-name="Узел последовательной агрегации, WhileCycleNode">Узел последовательной агрегации, WhileCycleNode</div></a><div class="tree-item-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector("#right-sidebar"); rs.classList.toggle("is-collapsed", window.innerWidth < 768); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></div></div></body></html>