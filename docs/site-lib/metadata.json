{"createdTime":1756112833034,"shownInTree":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/об-its_domainmodel.html","2.-вычисления-(its_reasoner)/об-its_reasoner.html","3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html","index.html"],"attachments":["site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css","images/relationship_demo.png","images/relationship_arity.png","images/relationship_linear_scale.png","images/relationship_partial_scale.png","images/nodes_branchresultnode.png","images/nodes_questionnode.png","images/nodes_tuplequestionnode.png","images/nodes_findactionnode.png","images/nodes_sim_and.png","images/nodes_sim_or.png","images/nodes_mutex.png","images/nodes_hyp.png","images/nodes_seq.png","images/nodes_branchaggregationnode.png","images/nodes_cycleaggregationnode.png","images/nodes_whilecyclenode.png","images/decision_tree_sample.png","site-lib/rss.xml"],"allFiles":["1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html","2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/об-its_domainmodel.html","index.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","images/nodes_seq.png","images/nodes_sim_or.png","images/nodes_sim_and.png","images/nodes_mutex.png","images/nodes_hyp.png","images/nodes_whilecyclenode.png","images/nodes_tuplequestionnode.png","images/nodes_questionnode.png","images/nodes_findactionnode.png","images/nodes_cycleaggregationnode.png","images/nodes_branchresultnode.png","images/nodes_branchaggregationnode.png","images/decision_tree_sample.png","images/relationship_partial_scale.png","images/relationship_linear_scale.png","images/relationship_demo.png","images/relationship_arity.png","site-lib/fonts/94f2f163d4b698242fef.otf","site-lib/fonts/72505e6a122c6acd5471.woff2","site-lib/fonts/2d5198822ab091ce4305.woff2","site-lib/fonts/c8ba52b05a9ef10f4758.woff2","site-lib/fonts/cb10ffd7684cd9836a05.woff2","site-lib/fonts/293fd13dbca5a3e450ef.woff2","site-lib/fonts/085cb93e613ba3d40d2b.woff2","site-lib/fonts/b5f0f109bc88052d4000.woff2","site-lib/fonts/cbe0ae49c52c920fd563.woff2","site-lib/fonts/535a6cf662596b3bd6a6.woff2","site-lib/fonts/70cc7ff27245e82ad414.ttf","site-lib/fonts/454577c22304619db035.ttf","site-lib/fonts/52ac8f3034507f1d9e53.ttf","site-lib/fonts/05b618077343fbbd92b7.ttf","site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","site-lib/media/6155340132a851f6089e.svg","site-lib/media/2308ab1944a6bfa5c5b8.svg","site-lib/html/file-tree-content.html","site-lib/scripts/webpage.js","site-lib/media/favicon.png","site-lib/styles/obsidian.css","site-lib/styles/global-variable-styles.css","site-lib/styles/main-styles.css"],"webpages":{"1.-модели-(its_domainmodel)/дерево-решений/выражения.html":{"title":"Выражения","icon":"","description":"В данном разделе описывается язык выражений, представляющих конкретные действия или рассуждения, выполняемые над <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области\" data-href=\"Модель предметной области\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">моделью предметной области</a>. Данные выражения чаще всего используются в составе <a data-tooltip-position=\"top\" aria-label=\"Узлы\" data-href=\"Узлы\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">узлов</a> <a data-tooltip-position=\"top\" aria-label=\"Дерево (граф) решений\" data-href=\"Дерево (граф) решений\" href=\"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">деревьев решений</a>, но могут использоваться и отдельно.\nДанный раздел соответствует пакету its.model.expressions в коде.Выражения выражают конкретные действия или рассуждения, выполняемые над моделью предметной области. Это подразумевает некоторую логику получения и/или изменения данных, хранящихся в модели предметной области (DomainModel).Каждый вид выражений в коде представлен отдельным классом-наследником от класса Operator, и может иметь дочерние выражения (операнды), представленные списком Operator.children.\nВыражения также имеют возвращаемый тип, представленный функцией Operator.resolvedType(DomainModel) (в общем случае тип выражения может зависеть от определений в модели предметной области).Ниже в данном разделе будут приведены все поддерживаемые виды выражений, и для каждого из них будет приведена их текстовая форма записи.<br>\nДанная текстовая форма считается частью <a data-href=\"LOQI\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">LOQI</a>-синтаксиса, хотя и не используется в обычных .loqi файлах (поскольку LOQI описывает в первую очередь модель предметной области, где выражений нет). Эта запись выражений (\"LOQI-выражения\") имеет некоторые общие синтаксические конструкции с обычной LOQI-записью модели, в связи с чем вынесена в ту же грамматику LoqiGrammar.g4Приоритеты в таблице расположены от наибольшего к наименьшемуДалее будут подробно рассмотрены отдельные виды выражений.Литералы-константы представляют некоторую константу, записываемую в выражении.\nВ коде все они являются наследниками ValueLiteral и имеют следующее содержание:\nValueLiteral.value - конкретное значение константы, представленное литералом. Имеет тип, соответствующий литералу.\n<br>ValueLiteral.type - <a data-tooltip-position=\"top\" aria-label=\"Типы данных\" data-href=\"Типы данных\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">тип данных</a> значения данного литерала.\n<br>Данные литералы полностью соответствуют <a data-tooltip-position=\"top\" aria-label=\"LOQI > Значения\" data-href=\"LOQI#Значения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Значения\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">значениям, описанным в разделе о LOQI</a>.\nВ коде они представлены:\nСтроковые константы (Строковый литерал) - StringLiteral\nЦелые числа (Целочисленный литерал) - IntegerLiteral\nДробные числа (Вещественный литерал) - DoubleLiteral\nБулевы значения (Булев литерал) - BooleanLiteral\nЗначения перечисления (Перечислимый литерал) - EnumLiteral\nПод ссылочными литерами подразумевается получение некоторой сущности по ссылающемуся на него имени.\nВ коде все они являются наследниками ReferenceLiteral и имеют следующее содержание:\nReferenceLiteral.name - имя, по которому происходит ссылка.\n<br>Important\nЗдесь и далее в этом разделе под именами подразумеваются идентификаторы, <a data-tooltip-position=\"top\" aria-label=\"LOQI > Идентификаторы (Имена)\" data-href=\"LOQI#Идентификаторы (Имена)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Идентификаторы (Имена)\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">определенные в разделе про LOQI</a> - см. туда для подробностей.\nСинтаксис:&lt;имя переменной&gt;\nПримеры: X, Y, MyVar\n(по конвенции стараемся использовать PascalCase - т.е. запись с большой буквы - для переменных дерева решений, для того чтобы было легче отличать от контекстных переменных)Смысл: Получить (вернуть) объект, записанный в переменную дерева решений.\nВозвращаемый тип: объект (ObjectType) соответствующего переменной класса (ObjectType.className)\nВ коде: DecisionTreeVarLiteralВалидация:\nПеременная, обозначенная данным именем, должна существовать в контексте валидации выражения (т.е. должна быть объявлена где-то в дереве решений, чтобы она могла быть использована в выражении)\nСинтаксис:$&lt;имя переменной&gt;\nПримеры: x1, y1, someVar\n(по конвенции стараемся использовать camelCase - т.е. запись с маленькой буквы - для контекстных переменных, для того чтобы было легче отличать от переменных дерева решений)Смысл: Получить объект, записанный в контекстную переменную.\nКонтекстные переменные отличаются от переменных дерева решений тем, что контекстные переменные вводятся внутри выражений и используются только внутри вводящих их выражений, а переменные дерева решений вводятся в узлах дерева решений и могут использоваться в различных выражениях.\nВозвращаемый тип: объект (ObjectType) соответствующего переменной класса (ObjectType.className)\nВ коде: VariableLiteralВалидация:\nПеременная, обозначенная данным именем, должна существовать в контексте валидации выражения (т.е. должна быть объявлена в выражении выше, чтобы она могла быть использована)\nСинтаксис:class:&lt;имя класса&gt;\nПримеры: class:MyClassСмысл: Получить класс, объявленный в модели, по его имени\nВозвращаемый тип: класс (ClassType), наследующийся от соответствующего класса (ClassType.className)\nВ коде: ClassLiteralВалидация:\nВ модели предметной области должен существовать класс с соответствующим именем.\nСинтаксис:obj:&lt;имя объекта&gt;\nПримеры: obj:someObjСмысл: Получить (вернуть) объект, объявленный в модели, по его имени.\nВозвращаемый тип: объект (ObjectType) соответствующего класса.\nВ коде: ObjectLiteralВалидация:\nВ модели предметной области должен существовать объект с соответствующим именем. Обратите внимание, что в контексте дерева решений, выражения валидируются относительно определенной заранее модели предметной области. В подобных моделях объектов зачастую нет - поэтому обращаться к объектам по имени нельзя. Исключение из этого правила составляют \"системные\" объекты, которые существуют в модели предметной области всегда. Синтаксис:&lt;выражение-объект&gt; is &lt;выражение-класс&gt;\nПримеры: X is class:OperatorСмысл: проверить, является ли объект экземпляром переданного класса. Данное выражение учитывает наследование (т.е. объект может быть не прямым наследником класса).\nВозвращаемый тип: булев (BooleanType) - true если является экземпляром, false иначе.\nВ коде: CheckClassВалидация:\nВыражение-объект должно возвращать объект (ObjectType)\nВыражение-класс должно возвращать класс (ClassType)\nТипы объекта и класса должны соответствовать - класс объекта должен быть супертипом для проверяемого класса. Потому что нет смысла проверять объект на принадлежность классу, которому он никогда не может принадлежать. Синтаксис:&lt;выражение-объект&gt; .class()\nПримеры: X is class:OperatorСмысл: получить прямой класс объекта.\nВозвращаемый тип: класс (ClassType), наследующийся от класса выражения-объекта\nВ коде: getClassВалидация:\nВыражение-объект должно возвращать объект (ObjectType)\nСинтаксис:\nВ базовой форме выражение выглядит так:&lt;выражение-объект&gt; .&lt;имя свойства&gt;\nПримеры: X.myProperty, obj:systemObj.descriptionУ выражения также есть параметризованная форма, для получения свойства по параметрам:&lt;выражение-объект&gt; .&lt;имя свойства&gt; &lt;значения параметров&gt;\nЗдесь и далее в этом разделе структура &lt;значения параметров&gt; определена как:&lt; &lt;имя параметра 1&gt; = &lt;выражение-параметр 1&gt;, ... &gt;\nИЛИ\n&lt; &lt;выражение-параметр 1&gt;, &lt;выражение-параметр 2&gt;, ... &gt;\n(В записи выше треугольные скобки &lt; &gt; в начале и конце строки должны интерпретироваться буквально.)\nПримеры записи значений параметров: &lt;myIntParam=2, myBoolParam=true&gt;, &lt;2, true&gt;\nПримеры записи параметризованной формы выражения получения свойства: X.myPropertyForEnum&lt;MyEnum:FIRST&gt;, Y.priority&lt;placement = Placement:Left, inParenthesis = true&gt;. Смысл: Получить (вернуть) значение свойства объекта. Если выражение параметризовано, то получить значение данного свойства для конкретного набора параметров.\nВозвращаемый тип: в соответствии с типом свойства.\nВ коде: GetPropertyValueВалидация:\nПолучать значение свойства можно только у объектов (ObjectType)\nДля данного типа объектов должно существовать получаемое свойство (должно быть объявлено в их родительских классах)\nСостав (имя и тип) параметров, переданных в выражении, должен соответствовать параметрам, объявленным для данного свойства\nЕсли для данного свойства объявлены параметры, то при получении свойства необходимо передать все объявленные параметры (нельзя заполнить параметры частично)\nСинтаксис:&lt;выражение-субъект&gt; =&gt;&lt;имя отношения&gt;[&lt;значения параметров&gt;](&lt;выражение-объект 1&gt;, ...)\n<br>(структура &lt;значения параметров&gt; подробно описана <a data-tooltip-position=\"top\" aria-label=\"Получение значения свойства\" data-href=\"#Получение значения свойства\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">выше</a>)\nПримеры: X=&gt;someRel(Y), X=&gt;isBetween(Y1, Y2), X=&gt;isOperandOf&lt;Placement:Left&gt;(Y)Смысл: Проверить, существует ли между объектами связь по заданному отношению. Если выражение параметризовано, то проверить, существует ли между объектами связь по заданному отношению, которая также содержит заданные значения параметров.\nВозвращаемый тип: булев (BooleanType) - true если связь существует, false если нет.\nВ коде: CheckRelationshipВалидация:\nВыражение-субъект и выражения-объекты должны быть объектами (ObjectType)\nДля заданных классов субъекта и объектов должно существовать заданное отношение <br>В данном выражении поддерживается <a data-tooltip-position=\"top\" aria-label=\"Отношения > Проекция\" data-href=\"Отношения#Проекция\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Проекция\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">проекция</a>, но для этого должно существовать единственное отношение, в которое будет спроецировано указанное. Количество заданных выражений-объектов должно быть равно объявленному для данного отношения количеству объектов\nСостав (имя и тип) параметров, переданных в выражении, должен соответствовать параметрам, объявленным для данного отношения (но можно передать неполный набор параметров).\nСинтаксис:&lt;выражение-субъект&gt; =&gt;&lt;имя отношения&gt;[&lt;значения параметров&gt;](&lt;выражение-объект 1&gt;, ...).&lt;имя получаемого параметра&gt;\n<br>(структура &lt;значения параметров&gt; подробно описана <a data-tooltip-position=\"top\" aria-label=\"Получение значения свойства\" data-href=\"#Получение значения свойства\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">выше</a>)\nПримеры: X=&gt;someRel(Y).myParam, X=&gt;isBetween(Y1, Y2).isAbove, X=&gt;isOperandOf&lt;Placement:Left&gt;(Y).priority<br>Смысл: найти между объектами связь по отношению, аналогично <a data-tooltip-position=\"top\" aria-label=\"Проверка наличия связи по отношению между объектами\" data-href=\"#Проверка наличия связи по отношению между объектами\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">проверке наличия связи</a>. Если таких связей нет, или их несколько, то будет выброшена ошибка выполнения. Иначе, если такая связь единственная, то получить у нее значение некоторого параметра по его имени.\nПримечания:\nДанное выражение не поддерживает проекцию, в отличие от проверки наличия связи\n<br>Для <a data-tooltip-position=\"top\" aria-label=\"Отношения > Типы зависимых отношений\" data-href=\"Отношения#Типы зависимых отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типы зависимых отношений\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">зависимых отношений</a> значения параметров определяются как описано в <a data-tooltip-position=\"top\" aria-label=\"Отношения > Параметризация\" data-href=\"Отношения#Параметризация\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Параметризация\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">соответствующем разделе</a>.\nВозвращаемый тип: в соответствии с типом получаемого параметра.\nВ коде: GetRelationshipParamValue\nВалидация:\n<br>Аналогично <a data-tooltip-position=\"top\" aria-label=\"Проверка наличия связи по отношению между объектами\" data-href=\"#Проверка наличия связи по отношению между объектами\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">проверке наличия связи</a>.\nДля заданного отношения должен существовать параметр с заданным именем.\nСинтаксис:find &lt;имя типа&gt; &lt;имя переменной поиска&gt; { &lt;выражение-условие поиска&gt; }\nПримеры: find Operator x { $x =&gt;isLeftOf(Y) }Important\nПоиск объектов, удовлетворяющих выражению-условию\nВ этом и других типах выражений используется общий механизм поиска объектов по условию.<br>\nУсловием обычно считается выражение, возвращающее булево значение, и имеющее внутри себя <a data-tooltip-position=\"top\" aria-label=\"Контекстная переменная\" data-href=\"#Контекстная переменная\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Контекстная_переменная_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">контекстные переменные</a>. Объект считается удовлетворяющим этому условию как переменная &lt;var&gt;, если существующая внутри данного выражения контекстная переменная &lt;var&gt; объявлена с типом, соответствующим типу данного объекта, и если при задании переменной &lt;var&gt; равной этому объекту, выражение-условие возвращает true.\nНапример, условием может выступать выражение $person.age &gt;= 18, где переменная $person объявлена с типом Person, и тогда объект obj alice : Person будет считаться удовлетворяющим данному условию как переменная $person, если его свойство .age больше или равно 18. Смысл: найти (вернуть) объект заданного типа, удовлетворяющий выражению условия поиска как переменная поиска. Если таких объектов нет, или их несколько, будет выброшена ошибка выполнения.\nВозвращаемый тип: объект (ObjectType) соответствующего объявленной переменной типа.\nВ коде: GetByConditionВалидация:\nОбъявленный для переменной тип должен существовать в модели\nОбъявляемое имя переменной не должно перекрывать уже существующие в данном контексте переменные.\nВыражение-условие поиска должно возвращать булево значение (BooleanType). Внутри выражения-поиска существует контекстная переменная поиска, объявленная данным оператором. Синтаксис:findExtreme &lt;имя экстремальной переменной&gt; [ &lt;выражение-условие экстремума&gt; ]\namong &lt;имя типа переменной&gt; &lt;имя общей переменной&gt; { &lt;выражение-условие поиска&gt; }\nПримеры: findExtreme x1 [ $x1 =&gt;isLeftOf($xToken) ] among token xToken { $xToken =&gt;belongsTo(X) }<br>Смысл: <a data-tooltip-position=\"top\" aria-label=\"Поиск объекта по условию\" data-href=\"#Поиск объекта по условию\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">найти</a> все объекты заданного типа, удовлетворяющие выражению условия поиска как общая переменная. Среди всех найденных объектов выбрать и вернуть такой, для которого выражение-условие экстремума выполняется при подстановке данного объекта как экстремальной контекстной переменной, и подстановке всех прочих найденных объектов как общей контекстной переменной.\nЕсли на любом из этапов подходящих объектов нет, или найдено несколько объектов, подходящих под условие экстремума, будет выброшена ошибка выполнения. Данное выражение по сути является синтаксическим сахаром, и может быть выражено через другие, более базовые выражения.\nТак, выражениеfindExtreme extremeVar [ &lt;extremeConditionExpr($extremeVar, $var)&gt; ]\namong type var { &lt;conditionExpr($var)&gt; }\nэквивалентно выражениюfind type extremeVar { &lt;conditionExpr($extremeVar)&gt; and forAll type var [&lt;conditionExpr($var)&gt; and $var != $extremeVar ] { &lt;extremeConditionExpr($extremeVar, $var)&gt; } }\n<br>(См. <a data-tooltip-position=\"top\" aria-label=\"Поиск объекта по условию\" data-href=\"#Поиск объекта по условию\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">поиск объекта по условию</a> и <a data-tooltip-position=\"top\" aria-label=\"Квантор общности (&quot;Для всех&quot;)\" data-href=\"#Квантор общности (&quot;Для всех&quot;)\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Квантор_общности_(&quot;Для_всех&quot;)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">квантор общности</a> для лучшего понимания выражения выше)Возвращаемый тип: объект (ObjectType) соответствующего объявленной переменной типа.\nВ коде: GetExtremeВалидация:\nОбъявленный для переменной тип должен существовать в модели\nОбъявляемые имена переменных не должны перекрывать уже существующие в данном контексте переменные, а также не должны совпадать\nВыражение-условие поиска должно возвращать булево значение (BooleanType). Внутри выражения-условия поиска существует общая контекстная переменная, объявленная данным оператором. Выражение-условие экстремума должно возвращать булево значение (BooleanType). Внутри выражения-условия экстремума существует общая контекстная переменная, а также экстремальная контекстная переменная, объявленные данным оператором Синтаксис:&lt;выражение-субъект&gt; -&gt;&lt;имя отношения&gt;[&lt;значения параметров&gt;]\n<br>(структура &lt;значения параметров&gt; подробно описана <a data-tooltip-position=\"top\" aria-label=\"Получение значения свойства\" data-href=\"#Получение значения свойства\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">выше</a>)\nПримеры: X-&gt;someRel, X-&gt;isOperandOf&lt;Placement:Left&gt;<br>Смысл: найти (вернуть) объект, с которым субъект связан заданным отношением. Находит для субъекта связи, определенные заданным отношением с заданными параметрами (аналогично <a data-tooltip-position=\"top\" aria-label=\"Проверка наличия связи по отношению между объектами\" data-href=\"#Проверка наличия связи по отношению между объектами\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">проверке наличия связи</a>), и получает объект данной связи. Если таких связей нет, или их несколько, то будет выброшена ошибка выполнения.Данное выражение по сути является синтаксическим сахаром, и может быть выражено через другие, более базовые выражения.\nТак, выражениеsomeObj-&gt;someRelationship&lt;...&gt;\nэквивалентно выражениюfind type anotherObj { someObj-&gt;someRelationship&lt;...&gt;($anotherObj)\n}\n<br>(См. <a data-tooltip-position=\"top\" aria-label=\"Поиск объекта по условию\" data-href=\"#Поиск объекта по условию\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">поиск объекта по условию</a> и <a data-tooltip-position=\"top\" aria-label=\"Проверка наличия связи по отношению между объектами\" data-href=\"#Проверка наличия связи по отношению между объектами\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">проверку наличия связи по отношению</a> для лучшего понимания выражения выше)Возвращаемый тип: объект (ObjectType) типа, соответствующего типу объекта связи.\nВ коде: GetByRelationshipВалидация:\nВыражение-субъект и выражения-объекты должны быть объектами (ObjectType)\nДля заданных классов субъекта и объектов должно существовать заданное отношение\nСостав (имя и тип) параметров, переданных в выражении, должен соответствовать параметрам, объявленным для данного отношения (но можно передать неполный набор параметров).\nСинтаксис:&lt;выражение 1&gt; and &lt;выражение 2&gt;\nПримеры: $a == $b and $a != $cСмысл: найти логическое И от двух выражений. Второе (правое) выражение не выполняется, если первое (левое) вернуло false\nВозвращаемый тип: булево значение (BooleanType)\nВ коде: LogicalAndВалидация:\nОба выражения-операнда должны возвращать булево значение (BooleanType)\nСинтаксис:&lt;выражение 1&gt; or &lt;выражение 2&gt;\nПримеры: $a == $b or $a != $cСмысл: найти логическое ИЛИ от двух выражений. Второе (правое) выражение не выполняется, если первое (левое) вернуло true\nВозвращаемый тип: булево значение (BooleanType)\nВ коде: LogicalOrВалидация:\nОба выражения-операнда должны возвращать булево значение (BooleanType)\nСинтаксис:not &lt;выражение&gt;\nПримеры: not ($a is class:MyClass)Смысл: вычислить логическое отрицание выражения операнда.\nВозвращаемый тип: булево значение (BooleanType)\nВ коде: LogicalNotВалидация:\nВыражение-операнд должно возвращать булево значение (BooleanType)\nСинтаксис:&lt;выражение 1&gt; == &lt;выражение 2&gt;\n&lt;выражение 1&gt; != &lt;выражение 2&gt;\n&lt;выражение 1&gt; &gt; &lt;выражение 2&gt;\n&lt;выражение 1&gt; &gt;= &lt;выражение 2&gt;\n&lt;выражение 1&gt; &lt; &lt;выражение 2&gt;\n&lt;выражение 1&gt; &lt;= &lt;выражение 2&gt;\nСмысл: сравнить значения двух выражений. Поддерживаются сравнения на (не)равество (для всех типов значений), а сравнения на больше/меньше (для численных значений)\nВозвращаемый тип: булево значение (BooleanType)\nВ коде: CompareWithComparisonOperatorВалидация:\nВозвращаемые типы выражений-операндов должны быть одинаковы, или приводимы друг к другу (численные типы в данном случае считаются приводимыми друг к другу)\nСравнения на больше/меньше применимы только к численным типам\nСинтаксис:&lt;выражение 1&gt; .compare( &lt;выражение 2&gt; )\nСмысл: сравнить величину значения двух выражений. Возвращает один из трех вариантов - больше/меньше/равно (относительно первого выражения, т.е. \"больше\" значит что первое больше второго и т.д.)<br>\nВозвращаемый тип: значение <a data-tooltip-position=\"top\" aria-label=\"Перечисления (Enum) > &quot;Встроенные&quot; перечисления\" data-href=\"Перечисления (Enum)#&quot;Встроенные&quot; перечисления\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html#&quot;Встроенные&quot; перечисления\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">встроенного перечисления</a> Comparison (EnumType)\nВ коде: CompareВалидация:\nВозвращаемые типы выражений-операндов должны быть численными\nСинтаксис:forAll &lt;имя типа&gt; &lt;имя переменной квантора&gt; [ &lt;выражение-условие выбора&gt;\n] { &lt;выражение-тело квантора&gt;\n}\nТакже допускается более короткая записьforAll &lt;имя типа&gt; &lt;имя переменной квантора&gt; { &lt;выражение-тело квантора&gt;\n}\nкогда &lt;выражение-условие выбора&gt; равно true (т.е. выбрать все объекты подходящего типа).\nПримеры:forAll Operand xOp [ $xOp=&gt;isOperandOf(X)\n] { $xOp.state == State:unevaluated\n} forAll Operand op { $op.state = State:evaluated\n}\n<br>Смысл: <a data-tooltip-position=\"top\" aria-label=\"Поиск объекта по условию\" data-href=\"#Поиск объекта по условию\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">найти</a> все объекты, удовлетворяющие условию выбора как переменная квантора. Далее в зависимости от типа выражения-тела квантора:\nЕсли выражение-тело возвращает булево значение, то вернуть true, если все найденные выше объекты удовлетворяют выражению-телу в качестве условия, как переменная квантора, иначе вернуть false - Проверяющий режим квантора. Обратите внимание, что проверяющий режим предполагает, что повторное или многократное выполнение тела квантора не приведет к изменениям результата выполнения или состояния модели. В связи с этим выполнение может прерваться сразу, если для одного из объектов тело квантора вернуло false. Во избежание нежелательных последствий, в данном режиме не стоит менять состояние модели. Иначе (если выражение-тело имеет другой тип), то выполнить выражение-тело для всех найденных объектов (подставляя объекты в качестве переменной квантора), и ничего не вернуть - Управляющий режим квантора (или режим цикла).\nВозвращаемый тип: булево значение (BooleanType) в проверяющем режиме, или ничего (NoneType) в управляющем режиме\nВ коде: ForAllQuantifierВалидация:\nВыражение-условие выбора должно возвращать булево значение (BooleanType). Внутри выражения-условия выбора и выражения-тела квантора существует контекстная переменная квантора, объявленная данным оператором. Синтаксис:forAny &lt;имя типа&gt; &lt;имя переменной квантора&gt; [ &lt;выражение-условие выбора&gt;\n] { &lt;выражение-тело квантора&gt;\n}\nТакже допускается более короткая записьforAny &lt;имя типа&gt; &lt;имя переменной квантора&gt; { &lt;выражение-тело квантора&gt;\n}\nкогда &lt;выражение-условие выбора&gt; равно true (т.е. выбрать все объекты подходящего типа).\nПримеры:forAny Operand xOp [ $xOp=&gt;isOperandOf(X)\n] { $xOp.state == State:unevaluated\n} forAny Operand op { $op.state = State:evaluated\n}\n<br>Смысл: <a data-tooltip-position=\"top\" aria-label=\"Поиск объекта по условию\" data-href=\"#Поиск объекта по условию\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">найти</a> все объекты, удовлетворяющие условию выбора как переменная квантора. Далее в зависимости от типа выражения-тела квантора:\nЕсли выражение-тело возвращает булево значение, то вернуть true, если любой из найденных выше объектов удовлетворяет выражению-телу как переменная квантора, иначе вернуть false - Проверяющий режим квантора. Обратите внимание, что проверяющий режим предполагает, что повторное или многократное выполнение тела квантора не приведет к изменениям результата выполнения или состояния модели. В связи с этим выполнение может прерваться сразу, если для одного из объектов тело квантора вернуло true. Во избежание нежелательных последствий, в данном режиме не стоит менять состояние модели. Иначе (если выражение-тело имеет другой тип), то выполнить выражение-тело для одного любого из найденных объектов (подставляя его в качестве переменной квантора), и ничего не вернуть - Управляющий режим квантора (или режим действия). Механизм выбора одного из объектов не определен данной спецификацией. Ожидается, что данный механизм будет использоваться в ситуациях, когда заранее известно, что подходящий объект один. Возвращаемый тип: булево значение (BooleanType) в проверяющем режиме, или ничего (NoneType) в управляющем режиме\nВ коде: ExistenceQuantifierВалидация:\nВыражение-условие выбора должно возвращать булево значение (BooleanType). Внутри выражения-условия выбора и выражения-тела квантора существует контекстная переменная квантора, объявленная данным оператором. Синтаксис:&lt;имя переменной&gt; = &lt;выражение-значение&gt;\nПримеры: X = Y-&gt;hasOperand Смысл: (пере)присвоить переменной дерева решений новое значение (объект).\nВозвращаемый тип: отсутствует (NoneType)\nВ коде: AssignDecisionTreeVarВалидация:\nПеременная, обозначенная данным именем, должна существовать в контексте валидации выражения (т.е. должна быть объявлена где-то в дереве решений, чтобы она могла быть использована в выражении)\nВыражение-значение должно возвращать объект (ObjectType), чей класс (ObjectType.className) совместим с объявленным для переменной типом.\nСинтаксис:&lt;выражение-объект&gt; .&lt;имя свойства&gt;[&lt;значения параметров&gt;] = &lt;выражение-значение&gt;\n<br>(структура &lt;значения параметров&gt; подробно описана <a data-tooltip-position=\"top\" aria-label=\"Получение значения свойства\" data-href=\"#Получение значения свойства\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">выше</a>)\nПримеры: X.state = State:unevaluated Смысл: (пере)присвоить свойству объекта новое значение.\nВозвращаемый тип: отсутствует (NoneType)\nВ коде: AssignPropertyВалидация:\nПолучать значение свойства можно только у объектов - выражение-объект должно возвращать объект (ObjectType)\nДля данного типа объектов должно существовать изменяемое свойство (должно быть объявлено в их родительских классах)\nСостав (имя и тип) параметров, переданных в выражении, должен соответствовать параметрам, объявленным для данного свойства\nЕсли для данного свойства объявлены параметры, то при изменения свойства необходимо передать все объявленные параметры (нельзя заполнить параметры частично)\nВыражение-значение должно возвращать иметь тип, совместимый с объявленным для переменной типом.\nСинтаксис:&lt;выражение-субъект&gt; +=&gt;&lt;имя отношения&gt;[&lt;значения параметров&gt;](&lt;выражение-объект 1&gt;, ...)\n<br>(структура &lt;значения параметров&gt; подробно описана <a data-tooltip-position=\"top\" aria-label=\"Получение значения свойства\" data-href=\"#Получение значения свойства\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">выше</a>)\nПримеры: X+=&gt;isOperandOf&lt;Placement:Left&gt;(Y)Смысл: добавить между указанными объектами связь по отношению.\nВозвращаемый тип: отсутствует (NoneType)\nВ коде: AddRelationshipLinkВалидация:\nВыражение-субъект и выражения-объекты должны быть объектами (ObjectType)\n<br>Для заданных классов субъекта и объектов должно существовать заданное отношение, и оно не может быть <a data-tooltip-position=\"top\" aria-label=\"Отношения > Характеристики отношений\" data-href=\"Отношения#Характеристики отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Характеристики отношений\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">зависимым</a>.\nКоличество заданных выражений-объектов должно быть равно объявленному для данного отношения количеству объектов\nСостав (имя и тип) параметров, переданных в выражении, должен соответствовать параметрам, объявленным для данного отношения.\nЕсли для данного отношения объявлены параметры, то при добавлении связи необходимо передать все объявленные параметры (нельзя заполнить параметры частично).\nСинтаксис:( &lt;выражение&gt; )\n<br>Смысл: явно указать больший приоритет для вложенного выражения - в случаях, когда <a data-tooltip-position=\"top\" aria-label=\"Таблица приоритетов выражений\" data-href=\"#Таблица приоритетов выражений\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Таблица_приоритетов_выражений_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">приоритет по-умолчанию</a> не подходит.\nОбычные скобки, как и везде.\nВозвращаемый тип: аналогичен вложенному выражению.\nВ коде отсутствуют (как отдельный класс выражений) - нужны только для парсинга текстовой записи выражений.Синтаксис:&lt;выражение-объект&gt; as &lt;выражение-класс&gt;\nПримеры: X as class:OperatorСмысл: расценивать результат выражения-объекта как объект заданного класса в данном контексте. Если при выполнении окажется, что данный объект не является экземпляром данного класса, то будет выброшена ошибка выполнения.\nВозвращаемый тип: объект (ObjectType) заданного класса.\nВ коде: CastВалидация:\nВыражение-объект должно возвращать объект (ObjectType)\nВыражение-класс должно возвращать класс (ClassType)\nТипы объекта и класса должны соответствовать - класс объекта должен быть супертипом для проверяемого класса. Потому что нет смысла пытаться привести объект к классу, которому он никогда не может принадлежать. Синтаксис:\nТернарная форма:&lt;выражение-условие&gt; ? &lt;выражение-then&gt; : &lt;выражение-else&gt; Примеры: X is Operator ? 1 : 2Условная форма:if(&lt;выражение-условие&gt;) &lt;выражение-then&gt; [else &lt;выражение-else&gt; ]\nПримеры: if(X is Operator) 1 else 2, if(X is Operator) X.state = State:unevaluatedСмысл: в зависимости от наличия выражения-else:\nЕсли выражение-else есть - Полное условие: Если выражение-условие выполняется, то выполнить выражение-then и вернуть его результат. Иначе выполнить выражение-else и вернуть его результат Если выражение-else отсутствует - Неполное условие: Если выражение-условие выполняется, то выполнить выражение-then. Ничего не возвращать. Возвращаемый тип: ближайший супертип типов -then и -else выражений при полном условии, и ничего (NoneType) при неполном условии.\nВ коде: IfThenВалидация:\nВыражение-условие должно возвращать булево значение (BooleanType)\nПри полном условии типы -then и -else выражений должны быть приводимы к общему типу (иметь общий супертип).\nСинтаксис:{ &lt;выражение 1&gt; ; &lt;выражение 2&gt; ; ... [;] }\nСмысл: последовательно выполнить вложенные выражения. Вернуть результат последнего выполненного выражения\nВозвращаемый тип: аналогично типу последнего выражения.\nВ коде: BlockВалидация: отсутствует","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общие принципы","level":2,"id":"Общие_принципы_0"},{"heading":"Синтаксис","level":2,"id":"Синтаксис_0"},{"heading":"Таблица приоритетов выражений","level":2,"id":"Таблица_приоритетов_выражений_0"},{"heading":"Литералы-константы","level":2,"id":"Литералы-константы_0"},{"heading":"Ссылочные литералы","level":2,"id":"Ссылочные_литералы_0"},{"heading":"Переменная дерева решений","level":3,"id":"Переменная_дерева_решений_0"},{"heading":"Контекстная переменная","level":3,"id":"Контекстная_переменная_0"},{"heading":"Ссылка на класс","level":3,"id":"Ссылка_на_класс_0"},{"heading":"Ссылка на объект (по имени)","level":3,"id":"Ссылка_на_объект_(по_имени)_0"},{"heading":"Операции получения данных из модели","level":2,"id":"Операции_получения_данных_из_модели_0"},{"heading":"Проверка класса объекта","level":3,"id":"Проверка_класса_объекта_0"},{"heading":"Получение класса объекта","level":3,"id":"Получение_класса_объекта_0"},{"heading":"Получение значения свойства","level":3,"id":"Получение_значения_свойства_0"},{"heading":"Проверка наличия связи по отношению между объектами","level":3,"id":"Проверка_наличия_связи_по_отношению_между_объектами_0"},{"heading":"Получить значение параметра связи между объектами","level":3,"id":"Получить_значение_параметра_связи_между_объектами_0"},{"heading":"Поиск объекта по условию","level":3,"id":"Поиск_объекта_по_условию_0"},{"heading":"Поиск объекта по условию экстремума","level":3,"id":"Поиск_объекта_по_условию_экстремума_0"},{"heading":"Получение объекта по связи по отношению","level":3,"id":"Получение_объекта_по_связи_по_отношению_0"},{"heading":"Логические операторы","level":2,"id":"Логические_операторы_0"},{"heading":"Логическое И","level":3,"id":"Логическое_И_0"},{"heading":"Логическое ИЛИ","level":3,"id":"Логическое_ИЛИ_0"},{"heading":"Логическое НЕ","level":3,"id":"Логическое_НЕ_0"},{"heading":"Сравнение двух значений","level":3,"id":"Сравнение_двух_значений_0"},{"heading":"Трехзначное сравнение двух значений","level":3,"id":"Трехзначное_сравнение_двух_значений_0"},{"heading":"Кванторы","level":2,"id":"Кванторы_0"},{"heading":"Квантор общности (\"Для всех\")","level":3,"id":"Квантор_общности_(\"Для_всех\")_0"},{"heading":"Квантор существования (\"Для любого\")","level":3,"id":"Квантор_существования_(\"Для_любого\")_0"},{"heading":"Модификация модели предметной области","level":2,"id":"Модификация_модели_предметной_области_0"},{"heading":"Присвоение переменной дерева решений","level":3,"id":"Присвоение_переменной_дерева_решений_0"},{"heading":"Присвоение значения свойству","level":3,"id":"Присвоение_значения_свойству_0"},{"heading":"Добавление связи по отношению между объектами","level":3,"id":"Добавление_связи_по_отношению_между_объектами_0"},{"heading":"Управление потоком выполнения выражений","level":2,"id":"Управление_потоком_выполнения_выражений_0"},{"heading":"Скобки","level":3,"id":"Скобки_0"},{"heading":"Приведение к типу (Cast)","level":3,"id":"Приведение_к_типу_(Cast)_0"},{"heading":"Условный оператор","level":3,"id":"Условный_оператор_0"},{"heading":"Блок выражений","level":3,"id":"Блок_выражений_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Литералы-константы_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Ссылочные_литералы_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_объекта_по_связи_по_отношению_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_класса_объекта_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получить_значение_параметра_связи_между_объектами_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Логическое_НЕ_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Сравнение_двух_значений_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Трехзначное_сравнение_двух_значений_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_класса_объекта_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Сравнение_двух_значений_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Приведение_к_типу_(Cast)_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Логическое_И_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Логическое_ИЛИ_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Добавление_связи_по_отношению_между_объектами_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Условный_оператор_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Присвоение_переменной_дерева_решений_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Присвоение_значения_свойству_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Условный_оператор_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Скобки_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_экстремума_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Квантор_общности_(\"Для_всех\")_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Квантор_существования_(\"Для_любого\")_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Блок_выражений_0","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Значения","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Идентификаторы (Имена)","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Проекция","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типы зависимых отношений","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Параметризация","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Контекстная_переменная_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Квантор_общности_(\"Для_всех\")_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Проверка_наличия_связи_по_отношению_между_объектами_0","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html#\"Встроенные\" перечисления","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Поиск_объекта_по_условию_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Получение_значения_свойства_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Характеристики отношений","1.-модели-(its_domainmodel)/дерево-решений/выражения.html#Таблица_приоритетов_выражений_0"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/дерево-решений/выражения.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001906,"modifiedTime":1755895710101,"sourceSize":54669,"sourcePath":"1. Модели (its_DomainModel)/Дерево решений/Выражения.md","exportPath":"1.-модели-(its_domainmodel)/дерево-решений/выражения.html","showInTree":true,"treeOrder":2,"backlinks":["2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html":{"title":"Дерево (граф) решений","icon":"","description":"В данном разделе описывается модель алгоритмов вычислений, выполняемых над <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области\" data-href=\"Модель предметной области\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">моделью предметной области</a>, представляемая в виде дерева (графа) решений.\nДанный раздел соответствует пакетам its.model.nodes и its.model.expressions в коде.Note\nПо-хорошему, фреймворк, представленный its_* проектами, должен работать с направленным ациклическим графом (Directed Acyclic Graph, DAG) решений, а не деревом - т.е. на один и тот же узел должны мочь ссылаться несколько узлов.<br>\nТак было не всегда - данная модель долгое время была просто деревом, поэтому название устоялось. Более того, даже сейчас в коде its_* проектов данная структура представлена именно деревом, без прямой поддержки DAG-структуры. Имитация DAG-структуры достигается путем дублирования узлов, имеющих несколько родительских узлов, во время экспорта из <a data-tooltip-position=\"top\" aria-label=\"https://github.com/Strupervlg/decision-tree-interface\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Strupervlg/decision-tree-interface\" target=\"_self\"><strong></strong></a>графического редактора - т.е., DAG преобразовывается в дерево.\nИменно поэтому здесь и далее в этом разделе данная структура будет называется деревом.\nПрежде всего, необходимо понимать, что дерево решений представляет собой запись некого алгоритма. Понять данную модель можно примерно как обычное представление алгоритма в виде блок-схемы: каждый узел дерева представляет один шаг алгоритма, а переходы между узлами - возможные переходы между данными шагами.Проще всего, наверное, рассмотреть на примере:<br>\n<img alt=\"decision_tree_sample.png\" src=\"images/decision_tree_sample.png\" target=\"_self\">\nЗдесь изображен весьма простой и несерьезный пример дерева решений, представляющего алгоритм проверки, выбран ли хороший питомец (для своеобразного определения \"хорошего питомца\").<br>Note\nВизуальное представление деревьев решений чаще всего реализуется с помощью графического редактора <a data-tooltip-position=\"top\" aria-label=\"https://app.diagrams.net/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://app.diagrams.net/\" target=\"_self\"><strong></strong> (он же <strong></strong>)</a>draw.iodiagrams.net - либо просто в условном схематическом виде (т.е. просто как рисунок), либо с использованием <a data-tooltip-position=\"top\" aria-label=\"https://github.com/Strupervlg/decision-tree-interface\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Strupervlg/decision-tree-interface\" target=\"_self\"><strong></strong></a>дополнительного расширения (называемого далее просто \"редактор\"), позволяющего задавать дереву необходимые для его формального представления в коде данные, и впоследствии их экспортировать для использования в коде.\nВ данной вики стандарты визуального представления объясняться не будут, но будут использованы для удобства.\nПроще говоря: про визуальное редактирование - не ко мне.\nТак, дерево решений принимает некоторые входные данные (в примере - Питомец Х, и Пользователь U, обозначены прямоугольником в самом верху дерева), с которыми затем производятся различные действия и проверки, для того, чтобы получить некий результат (в примере - узнать, был ли выбран хороший питомец).\nВ этом смысле дерево решений, опять таки, является просто алгоритмом или функцией - принимает данные, выполняет операции, и выдает результат.<br>Данные, которыми оперирует дерево решений, определяются соответствующей моделью предметной области. Подробнее об этом - <a data-tooltip-position=\"top\" aria-label=\"Связь с моделью предметной области\" data-href=\"#Связь с моделью предметной области\" href=\"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html#Связь_с_моделью_предметной_области_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ниже</a>.Каждый шаг (конкретная операция с данными) в данном алгоритме представлен конкретным узлом дерева; в зависимости от типа необходимых операций могут использоваться различные типы узлов (в примере используются только узлы-вопросы, обозначенные овалами).<br>\nПодробнее про виды узлов дерева читайте в <a data-tooltip-position=\"top\" aria-label=\"Узлы\" data-href=\"Узлы\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">соответствующей статье</a>.Конкретные операции с данными, выполняемые в узлах, записываются в них особым формальным языком выражений. В зависимости от типа узла, данные выражения могут играть различную роль - описывать формально выполняемые проверки, определять отдельные категории объектов и прочее.<br>\nПодробнее про виды выражений читайте в <a data-tooltip-position=\"top\" aria-label=\"Выражения\" data-href=\"Выражения\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">соответствующей статье</a>.Переходы между узлами совершаются в зависимости от результата выполнения операции в узле. Конкретный способ определения перехода зависит от используемого типа узла.В итоге прорешивания дерева (последовательного прохождения по его узлам и их выполнения) процесс завершается в одном из узлов-результатов, обозначенных на рисунке небольшими красными и зелеными прямоугольниками. Данные узлы, по сути, представляют собой ответ на вопрос, которым занимается дерево: \"Выбран ли хороший питомец?\" - \"Да, верно, выбран.\" или \"Нет, неверно, не выбран.\"В коде деревья представлены классом DecisionTree.\nСостав хранимой в нем информации:\nНабор базовых входных переменных (DecisionTree.variables)\nНабор вторичных входных переменных, вычисляемых на основе базовых (DecisionTree.implicitVariables)\nВетвь мысли, соответствующая основному \"телу\" дерева мысли (т.е. его основная часть, ответственная за вычисления) (DecisionTree.thoughtBranch)\nОтдельные элементы дерева решений представлены наследниками класса DecisionTreeElement.\nСостав базовой хранимой в нем информации:\nДерево решений, которому элемент принадлежит (DecisionTreeElement.decisionTree)\nРодительский элемент (DecisionTreeElement.parent)\n<br><a data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Метаданные</a> данного элемента (DecisionTreeElement.metadata).\nАлгоритмы, представляемые деревьями решений, можно разделить на два больших вида:А. Алгоритмы, призванные найти (построить или выбрать) конкретный ответ на поставленную задачу. Например, \"Какой тип значения возвращает данный вызов функции?\". В этом случае дерево должно вернуть конкретный, подходящий к ситуации, ответ.\nТакие деревья назвываются решающими (или \"зелеными\", т.к. их узлы-результаты имеют только корректные ответы, визуально отмечаемые зеленым цветом).Б. Алгоритмы, призванные проверить ответ, уже данный на поставленную задачу. Например, \"Возвращает ли данный вызов функции указанный тип Т?\". В этом случае дерево должно вернуть результат данной проверки - правилен ли ответ, или нет.\nТакие деревья называются проверяющими (или \"красно-зелеными\", т.к. в этом случае узлы-результаты обозначают как верные, так и неверные ответы, и могут обозначаться зеленым или красным цветом соответственно).Данные виды деревьев отражают, в общем, два разных подхода к построению обучающих систем - model-tracing (буквально \"прослеживание модели\") для решающих деревьев, и constraint-based (\"основанный на ограничениях\") для проверяющих деревьев.\nИх использование, соответственно, обусловлено различными необходимостями - так, например, решающие деревья хороши, когда необходимо научить студента самому решать конкретную задачу, а проверяющие - когда необходимо показать ему, какие законы (ограничения) предметной области нарушил его неправильный ответ, и научить самому проверять ответ.По названным выше примерам задач также легко видеть, что решающие деревья, чей набор ответов конечен, могут быть преобразованы в перебор ответов и их проверку по проверяющим деревьям.Warning\nНа данный момент код проекта поддерживает работу только с проверяющими деревьями - до сих пор на практике деревья использовались только в рамках индивидуальных тренажеров для студентов, при проверке их ответов на представленные вопросы. Поэтому в решающих деревьях просто не было необходимости.\nВ связи с этим здесь и далее речь ведется только о проверяющих деревьях.\nТем не менее, существенных различий в этих видах деревьев нет - за исключением выдаваемых ими результатов. <br>Для того, чтобы определить возможность тех или иных действий в дереве, оно должно быть связано с <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области\" data-href=\"Модель предметной области\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">моделью предметной области</a> - необходимо определить, какими <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классами</a> объектов дерево оперирует, а следовательно и какие их <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойства</a> и <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношения</a> ему \"известны\".Таким образом, дерево решений никогда не существует \"в вакууме\", а привязано к конкретной модели предметной области.Для этого в коде существует класс DomainSolvingModel - он объединяет в себе следующие данные:\nМодель предметной области (домена), общее для всех ситуаций применения (DomainSolvingModel.domainModel) Части предметной области, специфичные для отдельных ситуаций применения (т.н. теги) (DomainSolvingModel.tagsData) Деревья решений, описывающие решение задач данной в предметной области (DomainSolvingModel.decisionTrees)<br>\nПодробнее о различных частях модели предметной области см. в \"<a data-tooltip-position=\"top\" aria-label=\"Модель предметной области > Составление модели из частей\" data-href=\"Модель предметной области#Составление модели из частей\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Составление модели из частей\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Составление модели из частей</a>\"\n<br>Стоит отметить, что при хранении данной модели речь идет только о статической (постоянной) части предметной области - т.е., <a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объекты</a> в данных моделях почти всегда отсутствуют, поскольку отражают \"динамическую\" часть предметной области, отличающейся для каждой конкретной задачи. Корректность записи дерева решений выражается в двух составляющих\nВалидность конструкций - удовлетворение конструкциями собственных смысловых ограничений (например, использование булевских выражений в условных конструкциях и т.п.)\nСоответствие конструкций модели предметной области - не нарушение смысловых ограничений, наложенных спецификой предметной области (например, использование только существующих свойств или отношений, и т.п.)\nЗдесь, в отличие от модели предметной области, данное различие нужно только для удобства понимания корректности данных.\nСама валидация дерева вызывается методом DecisionTreeElement.validate (для выбрасывания исключений) или DecisionTreeElement.validateAndGet (для получения всего списка ошибок).\nСоответственно, корректность дерева обусловлена корректностью всех составляющих его элементов.Наиболее общим методом валидации является метод DomainSolvingModel.validate, который проверяет корректность всех входящих в него моделей. Здесь учитывается следующее:\n<br>Модель домена DomainSolvingModel.domainModel проверяется на <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области > Валидация модели\" data-href=\"Модель предметной области#Валидация модели\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Валидация модели\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">полную корректность</a> <br>Все теговые части модели из DomainSolvingModel.tagsData проверяются на <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области > Валидация модели\" data-href=\"Модель предметной области#Валидация модели\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Валидация модели\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">полную корректность</a>, с учетом того, что при использовании они объединяются с общей моделью DomainSolvingModel.domainModel Деревья решений из DomainSolvingModel.decisionTrees проверяются на корректность с учетом того, что при использовании они должны мочь работать с любой из объединенных теговых моделей (т.е. валидация происходит для всех тегов)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общие принципы","level":2,"id":"Общие_принципы_0"},{"heading":"Виды деревьев решений","level":2,"id":"Виды_деревьев_решений_0"},{"heading":"Связь с моделью предметной области","level":2,"id":"Связь_с_моделью_предметной_области_0"},{"heading":"Валидация","level":2,"id":"Валидация_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html#Связь_с_моделью_предметной_области_0","1.-модели-(its_domainmodel)/дерево-решений/узлы.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Составление модели из частей","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Валидация модели","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Валидация модели"],"author":"","coverImageURL":"images/decision_tree_sample.png","fullURL":"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","pathToRoot":"../..","attachments":["images/decision_tree_sample.png"],"createdTime":1755797001907,"modifiedTime":1755895710104,"sourceSize":17827,"sourcePath":"1. Модели (its_DomainModel)/Дерево решений/Дерево (граф) решений.md","exportPath":"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","showInTree":true,"treeOrder":3,"backlinks":["2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/дерево-решений/узлы.html":{"title":"Узлы","icon":"","description":"Узлы в <a data-tooltip-position=\"top\" aria-label=\"Дерево (граф) решений\" data-href=\"Дерево (граф) решений\" href=\"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">дереве решений</a> обозначают отдельные шаги в задаваемом деревом алгоритме.\nВ коде узлы представлены классами пакета its.model.nodes.<br>Узлы могут содержать <a data-tooltip-position=\"top\" aria-label=\"Выражения\" data-href=\"Выражения\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">выражения</a> для обозначения более низкоуровневой логики взаимодействия с данными.\nВ аналогии с обычными языками программирования узлы соответствуют statement-ам, а выражения - expression-ам. Если не углубляться в отдельные узлы дерева решений, в нем можно выделить отдельные ветви мысли. Сами по себе ветви представляют некоторую логически завершенную часть полного алгоритма, и отвечают на какой-то конкретный вопрос.\nВ аналогии с обычными языками программирования ветви мысли соответствуют отдельным функциям/процедурам.В коде ветви мысли представлены классом ThoughtBranch, и имеют ссылку на узел, представляющий их начало - ThoughtBranch.start.Аналогично любой функции, ветвь мысли должна выдавать результат - ответ на соответствующий ей вопрос. В этом смысле все дерево является одной большой ветвью мысли (которое зачастую разделяется на более мелкие) - поскольку выдает ответ на основной вопрос задачи.\nПо результату своего выполнения, ветви мысли могут иметь следующие результаты, представленные в коде перечислением BranchResult\nПравильно/верно/true (BranchResult.CORRECT) - с точки зрения данной ветви все выполнено правильно, ответ на вопрос ветви \"Да\".\nНеправильно/ошибка/false (BranchResult.ERROR) - с точки зрения данной ветви была допущена ошибка, ответ на вопрос ветви \"Нет\".\nНеизвестно/невозможно определить корректность/null (BranchResult.NULL) - данная ветвь не смогла выдать определенный ответ; либо ситуация слишком неожиданная, либо ветвь решает \"передать управление\" далее по дереву.\nВыдаваемый ветвью результат определяется в последнем узле, в который пришло его выполнение. В коде классы узлов, которые могут так выдавать результаты, реализовывают интерфейс EndingNode - это либо узлы результатов, либо узлы агрегации.Узлы результатов представляют собой основной способ завершить ветвь мысли и вернуть из нее какой-то результат.<br>\n<img alt=\"nodes_BranchResultNode.png\" src=\"images/nodes_branchresultnode.png\" target=\"_self\">\nВ коде они представлены классом BranchResultNode, и содержат следующую информацию:\nBranchResultNode.value - результат, возвращаемый узлом.\nBranchResultNode.actionExpr (может отсутствовать) - выражение, задающее действие, которое необходимо выполнить по достижении этого узла.\nПоведение при прорешивании:\nЕсли оно есть, то выполняется выражение BranchResultNode.actionExpr\nТекущая ветвь мысли считается завершенной с результатом BranchResultNode.value.\nВалидация:\nВыражение BranchResultNode.actionExpr должно быть валидным, и соответствовать известной в дереве на данный момент информации.\nОсновное множество узлов, имеющих собственную внутреннюю логику, называются \"связующими\", поскольку предполагают переход к другим узлам (а то есть связь с ними).\nВ коде такие узлы наследуются от класса LinkNode.Основной отличительной чертой таких узлов является набор переходов, представленный в коде полем LinkNode.outcomes. Данное поле имеет тип Outcomes, и по сути представляет собой соответствие ключа перехода и узла, к которому должен быть совершен переход. Данное соответствие представлено коллекцией единичных переходов (объектов класса Outcome), каждый из которых хранит соответствующие ключ Outcome.key и узел Outcome.node.\nВ процессе прорешивания из узла совершается тот переход, чей ключ соответствует ответу узла (тип этого ответа и ключей переходов зависит от конкретной специфики узла).Стоит отметить, что каждый отдельный переход Outcome в контейнере Outcomes наследуется от класса DecisionTreeElement, а значит может иметь метаданные. Это бывает полезно, поскольку бывают случаи привязки метаданных не к узлу в общем, а к конкретному переходу из него.Большинство узлов в типичном дереве решений является узлами вопросов. Данные узлы представляют собой необходимость выполнить некоторые рассуждения над ситуацией (задаться некоторым вопросом), и в зависимости от результата этих рассуждений (ответа на вопрос) совершить переход к различным следующим узлам.<br><img alt=\"nodes_QuestionNode.png\" src=\"images/nodes_questionnode.png\" target=\"_self\">\nОбычный узел вопроса представлен классом QuestionNode, и содержит следующую информацию:\nQuestionNode.expr - выражение, представляющее рассуждения (вопрос) в этом узле\nQuestionNode.outcomes (наследуется от LinkNode) - переходы к следующим узлам; ключом перехода является результат выражения QuestionNode.expr.\nQuestionNode.trivialityExpr (может отсутствовать и в большинстве случаев отсутствует) - предикат тривиальности: булево выражение, возвращающее true, если узел должен считаться тривиальным. Тривиальные узлы считаются очевидными, и на них не должно заостряться внимание пользователя. При прорешивании тривиальность напрямую не используется, а является вспомогательной информацией для сторонних проектов.\nQuestionNode.isSwitch (может отсутствовать и в большинстве случаев отсутствует) - флаг, означающий, что узел это тривиальная развилка (\"switch\"). Аналогично QuestionNode.trivialityExpr, но константа.\nПоведение при прорешивании:\nВычисляется выражение QuestionNode.expr\nСреди переходов QuestionNode.outcomes находится тот, чей ключ соответствует результату вычисления выражения Если такого нет, то выкидывается ошибка Решение переходит к узлу, соответствующему найденному переходу.\nВалидация:\nВложенные выражения должны быть валидными, и соответствовать известной в дереве на данный момент информации.\nТипы ключей всех переходов QuestionNode.outcomes должны соответствовать типу возвращаемого значения выражения QuestionNode.expr\nТип возвращаемого значения выражения QuestionNode.trivialityExpr должен быть булевым значением.\n<br><img alt=\"nodes_TupleQuestionNode.png\" src=\"images/nodes_tuplequestionnode.png\" target=\"_self\">\nУзел вопроса с кортежем или вопроса с несколькими частями отличается от обычного тем, что совершает несколько проверок одновременно, и совершает переход в зависимости от комбинаций ответов на них.Узел вопроса с кортежем представлен классом TupleQuestionNode, и содержит следующую информацию:\nTupleQuestionNode.parts - список отдельных частей данного вопроса. Каждая такая часть представлена классом TupleQuestionPart и содержит следующую информацию: TupleQuestionPart.expr - выражение, представляющее рассуждения (вопрос) в этой части узла\nTupleQuestionPart.possibleOutcomes - вспомогательный список ожидаемых результатов вычисления выражения TupleQuestionPart.expr. При прорешивании напрямую не используются, а являются вспомогательной информацией для сторонних проектов. TupleQuestionNode.outcomes (наследуется от LinkNode) - переходы к следующим узлам; ключом перехода является объект ValueTuple - кортеж значений, составляемый из результатов вычислений выражений TupleQuestionPart.expr всех частей TupleQuestionNode.parts данного узла.\nПоведение при прорешивании:\nДля всех частей TupleQuestionNode.parts вычисляется их выражение TupleQuestionPart.expr\nИз полученных результатов составляется кортеж ValueTuple\nСреди переходов TupleQuestionPart.outcomes находится тот, чей ключ (кортеж) соответствует полученному на предыдущем шаге кортежу результатов Если такого нет, то выкидывается ошибка Решение переходит к узлу, соответствующему найденному переходу.\nВалидация:\nВ узле должно быть как минимум две части TupleQuestionNode.parts (иначе нужно использовать QuestionNode)\nДля каждой части TupleQuestionNode.parts: Вложенные выражения должны быть валидными, и соответствовать известной в дереве на данный момент информации.\nТипы ожидаемых результатов TupleQuestionPart.possibleOutcomes должны соответствовать типу возвращаемого значения выражения TupleQuestionPart.expr Ключи всех переходов TupleQuestionPart.outcomes должны быть кортежами ValueTuple, а также количество и типы значений в этих кортежах должны соответствовать количеству и типу выражений в частях узла.\nУзлы действий представляют собой некоторую манипуляцию с данными о задаче - необходимо либо изменить ситуацию, либо получить и запомнить некоторую информацию.<br><img alt=\"nodes_FindActionNode.png\" src=\"images/nodes_findactionnode.png\" target=\"_self\">\nУзел действия поиска по своей сути аналогичен оператору присвоения в обычном языке программирования - он получает (находит) некоторый объект, и запоминает его как некоторую переменную дерева мысли.\nДанная переменная впоследствии доступна из всех выражений в узлах этой ветви мысли (но не за пределами этой ветви мысли).Узел действия поиска представлен классом FindActionNode, и содержит следующую информацию:\nFindActionNode.varAssignment - основное объявление/присвоение переменной. Имеет тип DecisionTreeVarAssignment, содержащий следующую информацию: DecisionTreeVarAssignment.variable - информация о переменной. Содержит тип (TypedVariable.className) и имя (TypedVariable.varName) переменной.\nDecisionTreeVarAssignment.valueExpr - выражение для вычисления значения переменной. Должно вернуть объект. FindActionNode.errorCategories - вспомогательный список категорий ошибок. При прорешивании напрямую не используются, а являются вспомогательной информацией для сторонних проектов. Каждая категория ошибок имеет тип FindErrorCategory, и содержит следующую информацию: FindErrorCategory.priority - приоритет данной категории ошибок. Eсли объект соответствует нескольким категориям, то будет выбрана категория с наивысшим приоритетом (1 считается наивысшим приоритетом, и далее 2, 3.. по убыванию)\nFindErrorCategory.selectorExpr - выражение предикат поиска: булево выражение, которое должно вернуть true, если объект соответствует данной категории ошибки. Проверяемый объект в данном выражении представлен контекстной переменной с именем \"checked\". FindActionNode.secondaryAssignments - т.н. \"вторичные\" объявления/присвоения переменных. Представляют собой список присвоений DecisionTreeVarAssignment (данный класс уже был описан выше). Данные присвоения выполняются только в случае, если основное FindActionNode.varAssignment было успешно выполнено. Также, во вторичных присвоениях также можно ссылаться на основную переменную узла. Таким образом, вторичные присвоения можно использовать, если в одном узле необходимо объявить сразу несколько связанных переменных. При этом предполагается, что внимание студента заостряется только на основном присвоении. FindActionNode.outcomes (наследуется от LinkNode) - переходы к следующим узлам; ключом перехода является булево значение - true, если основное присвоение успешно выполнено (объект найден), false в противном случае. Переход с ключом false может отсутствовать, если предполагается, что объект всегда будет найден; переход с ключом true должен быть обязательно. Поведение при прорешивании:\nДля основного присвоения FindActionNode.varAssignment вычисляется выражение DecisionTreeVarAssignment.valueExpr\nЕсли значение основного присвоения не было найдено, то решение переходит к узлу, соответствующему переходу с ключом false\nЕсли значение основного присвоения было найдено, то данный объект-значение запоминается в переменную дерева, соответствующую описанию переменной DecisionTreeVarAssignment.variable в основном присвоении FindActionNode.varAssignment\nАналогично основному присвоению выполняются все вторичные присвоения FindActionNode.secondaryAssignments: вычисляются объекты-значения, запоминаются переменные Если на данном этапе какое-либо из вторичных присвоений не удается (объект-значение не найден), то выкидывается ошибка - предполагается, что такая ситуация невозможна. Решение переходит к узлу, соответствующему переходу с ключом true. Здесь и далее в этой ветви мысли переменные, объявленные в узле поиска, доступны в виде переменных дерева. Валидация:\nВложенные выражения должны быть валидными и соответствовать известной в дереве на данный момент информации.\nВыражения в присвоениях FindActionNode.varAssignment и FindActionNode.secondaryAssignments должны иметь возвращаемый тип Объект, соответствующий классу, заявленному для соответствующей переменной.\nТип возвращаемого значения выражений в FindActionNode.errorCategories должен быть булевым значением Ключи всех переходов FindActionNode.outcomes должны быть булевыми значениями; переход с ключом true должен быть обязательно. Note\nНа данный момент действие поиска - единственный узел действий в системе, поскольку до сих пор не возникало необходимости выполнять какие-то еще другие действия в \"середине\" решения.\nОднако весьма вероятно, что в какой-то момент также понадобится узел выполнения произвольных выражений над операцией. На данный момент такие действия возможны только в рамках узлов результатов BranchResultNode - но они, закономерно, могут выполняться только в конце конкретной ветви мысли.\nАналогично же функциям, более высокоуровневые ветви мысли могут \"вызывать\" более низкоуровневые. Это происходит в случаях, если для определения ответа на вопрос высокоуровневой ветви нужны некие отдельные ответы на более низкоуровневые вопросы.На данный момент в проекте выделено 4 вида агрегации (5, если считать последовательность). В коде эти виды представлены перечислением AggregationMethod. Рассмотрим их:Независимые проверки по логическому И, SIM:AND\nSIM от слова SIMultaneous, одновременно<br>\n<img alt=\"nodes_sim_and.png\" src=\"images/nodes_sim_and.png\" target=\"_self\">\nПрименяется, когда необходимо сделать несколько проверок независимо друг от друга и отобразить их результат. При этом любая ошибка во вложенных ветвях приводит к ошибке в основной ветви.\nРезультат для основной ветви вычисляется так:\nnull, если все ветви такие\ntrue, если все ветви либо true либо null\nfalse иначе\nПри этом, из узла агрегации по SIM:AND всегда должен быть переход по true результату, т.к. в этом случае решение продолжается.\nНезависимые проверки по логическому ИЛИ, SIM:OR<br>\n<img alt=\"nodes_sim_or.png\" src=\"images/nodes_sim_or.png\" target=\"_self\">\nПрименяется, когда необходимо сделать несколько проверок независимо друг от друга и отобразить их результат. При этом, если хотя бы одна из вложенных ветвей выполнена корректно, то и основная ветвь считается выполненной корректно.\nРезультат для основной ветви вычисляется так:\nnull, если все ветви такие\ntrue, если хотя бы одна ветвь true\nfalse иначе\nПри этом, из узла агрегации по SIM:OR всегда должны быть переходы по false и null результатам, т.к. эти случаи возникают только при рассмотрении всех ветвей вместе, поэтому рассматривать данные результаты нужно на верхнем уровне.\nВзаимоисключающие проверки, MUTEX\nMUTEX от слов MUTually EXclusive, взаимно исключающий<br>\n<img alt=\"nodes_mutex.png\" src=\"images/nodes_mutex.png\" target=\"_self\">\nПрименяется, когда необходимо сделать несколько проверок независимо друг от друга и отобразить результат одной из них - предполагается, что в любой ситуации только одна из данных проверок даст какой-либо определенный результат (true либо false), а все остальные выдадут неопределенность (null).\nРезультат для основной ветви вычисляется так:\nЕсли среди ветвей есть результат true или false, то берется он\nnull иначе\nОбязательных переходов из узла агрегации по MUTEX нет, но чаще всего из него реализуется переход по null - \"Если не выполнилось ничего из перечисленного то переходить сюда\".\nГипотезы, HYP\nHYP от слова HYPothesis, гипотеза<br>\n<img alt=\"nodes_hyp.png\" src=\"images/nodes_hyp.png\" target=\"_self\">\nПрименяется, когда системе необходимо делать предположения (гипотезы) о том, как мог бы рассуждать обучаемый, чтобы прийти к своему ответу, потому что сам ответ не дает однозначной информации для этого.\nРезультат для основной ветви вычисляется так:\ntrue, если хотя бы одна ветвь true\nfalse, если хотя бы одна ветвь false\nnull иначе\nПри этом, из узла агрегации по HYP всегда должны быть переходы по null результату, т.к. этот случай может возникнуть только при рассмотрении всех ветвей вместе, поэтому рассматривать его нужно на верхнем уровне.\nПоследовательность, SEQ\nSEQ от слова SEQuence, последовательность<br>\n<img alt=\"nodes_seq.png\" src=\"images/nodes_seq.png\" target=\"_self\">\nПоследовательность является особым видом агрегации, который на первый взгляд может даже не казаться агрегацией. Он применяется, когда необходимо последовательно выполнить несколько проверок и вернуть первый определенный (true или false) результат.\nУчитывая эту формулировку, технически можно сказать, что большинство узлов в дереве объединяются агрегацией SEQ, поскольку идут последовательно друг за другом, и выполнение завершается на первом встреченном результате.\n<br>В то же время, агрегацию SEQ по ветвям нельзя реализовать аналогично остальным типам агрегации, поскольку он требует задания некоторого порядка, в котором проверяются ветви. Подробнее об этом см. <a data-tooltip-position=\"top\" aria-label=\"Узел последовательной агрегации, WhileCycleNode\" data-href=\"#Узел последовательной агрегации, WhileCycleNode\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_последовательной_агрегации,_WhileCycleNode_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">WhileCycleNode</a>. В связи с этим, SEQ отсутствует в перечислении AggregationMethod.\nРезультат для основной ветви вычисляется так: Берется результат первой из ветвей, чей результат не null (true или false); последующие ветви не выполняются.\nЕсли все ветви выдали null, то null\nПри этом, из узла агрегации по SEQ всегда должны быть переходы по null результату, т.к. именно в нем необходимо определить действия, выполняемые после завершения последовательности.\n<br><img alt=\"nodes_BranchAggregationNode.png\" src=\"images/nodes_branchaggregationnode.png\" target=\"_self\"><br>\nУзел агрегации по ветвям предполагает агрегацию нескольких различных (непохожих друг на друга) проверок, представленных несколькими отдельными ветвями мысли. Это одна из двух основных форм агрегации, вторая - <a data-tooltip-position=\"top\" aria-label=\"Узел агрегации в цикле по объектам, CycleAggregationNode\" data-href=\"#Узел агрегации в цикле по объектам, CycleAggregationNode\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">CycleAggregationNode</a>В коде данный узел представлен классом BranchAggregationNode и содержит следующую информацию:\nBranchAggregationNode.aggregationMethod - метод агрегации результатов ветвей в данном узле.\nBranchAggregationNode.thoughtBranches - список агрегируемых ветвей мысли.\nBranchAggregationNode.outcomes (наследуется от LinkNode) - переходы к следующим узлам; ключом перехода является результат агрегации вложенных ветвей BranchResult.\nПоведение при прорешивании:\nВыполняются все вложенные ветви мысли BranchAggregationNode.thoughtBranches, их результаты запоминаются\nНа основе метода агрегации BranchAggregationNode.aggregationMethod в данном узле, а также результатов вложенных ветвей, вычисляется результат BranchResult данного узла.\nЕсли у данного узла есть переход с ключом, соответствующим полученному результату, то решение переходит к узлу, соответствующему данному переходу. Иначе текущая ветвь мысли считается завершенной с результатом, соответствующим полученному.\nВалидация:\nСписок агрегируемых ветвей BranchAggregationNode.thoughtBranches не должен быть пустым.\nПереходы из узла должны содержать переходы с обязательными ключами, соответствующими виду агрегации. <br><img alt=\"nodes_CycleAggregationNode.png\" src=\"images/nodes_cycleaggregationnode.png\" target=\"_self\"><br>\nУзел агрегации в цикле по объектам предполагает агрегацию нескольких однотипных проверок, применяющихся к нескольким объектам в задаче. Это вторая из двух основных форм агрегации, первая - <a data-tooltip-position=\"top\" aria-label=\"Узел агрегации по ветвям, BranchAggregationNode\" data-href=\"#Узел агрегации по ветвям, BranchAggregationNode\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_по_ветвям,_BranchAggregationNode_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">BranchAggregationNode</a>.В коде данный узел представлен классом CycleAggregationNode и содержит следующую информацию:\nCycleAggregationNode.aggregationMethod - метод агрегации результатов ветвей в данном узле.\nCycleAggregationNode.thoughtBranch - ветвь мысли, представляющая тело цикла.\nCycleAggregationNode.variable - переменная перебора цикла. Данная переменная доступна как переменная дерева в теле цикла (но не вне его).\nCycleAggregationNode.selectorExpr - выражение предикат поиска: булево выражение, которое должно вернуть true для всех объектов, которые должны перебираться в цикле; проверяемый объект подставляется в предикат как контекстная переменная с именем и типом соответствующими переменной CycleAggregationNode.variable\n<br>CycleAggregationNode.errorCategories - вспомогательный список категорий ошибок. При прорешивании напрямую не используются, а являются вспомогательной информацией для сторонних проектов. Каждая категория ошибок имеет тип FindErrorCategory, который был подробно описан в <a data-tooltip-position=\"top\" aria-label=\"Действие поиска (найти объект и запомнить), FindActionNode\" data-href=\"#Действие поиска (найти объект и запомнить), FindActionNode\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">разделе о FindActionNode</a>\nCycleAggregationNode.outcomes (наследуется от LinkNode) - переходы к следующим узлам; ключом перехода является результат агрегации вложенных ветвей BranchResult.\nПоведение при прорешивании:\nПеребираются объекты типа, объявленного для переменной цикла CycleAggregationNode.variable. Из них оставляются те, для которых предикат поиска CycleAggregationNode.selectorExpr выдает true Для каждого найденного объекта выполняется тело цикла CycleAggregationNode.thoughtBranch, результаты каждой итерации запоминаются. В теле цикла соответствующий объект доступен как переменная дерева с именем и типом, соответствующим переменной цикла CycleAggregationNode.variable.\nНа основе метода агрегации CycleAggregationNode.aggregationMethod в данном узле, а также результатов итераций для объектов, вычисляется результат BranchResult данного узла.\nЕсли у данного узла есть переход с ключом, соответствующим полученному результату, то решение переходит к узлу, соответствующему данному переходу. Иначе текущая ветвь мысли считается завершенной с результатом, соответствующим полученному.\nВалидация:\nВложенные выражения должны быть валидными и соответствовать известной в дереве на данный момент информации.\nТип возвращаемого значения выражения предиката поиска CycleAggregationNode.selectorExpr, а также выражений в CycleAggregationNode.errorCategories должен быть булевым значением Переходы из узла должны содержать переходы с обязательными ключами, соответствующими виду агрегации. <br><img alt=\"nodes_WhileCycleNode.png\" src=\"images/nodes_whilecyclenode.png\" target=\"_self\">\nУзел последовательной агрегации по сути аналогичен обычному циклу \"while\" в языках программирования. Поскольку агрегацию по SEQ невозможно выполнить в узлах агрегации по ветвям или по объектам, она вынесена в данный узел.<br>\nДанный узел во многом похож на цикл по объектам, но выполняет свое тело, пока выполняется некоторое условие, или пока не найден определенный (true или false) результат. Предполагается, что результат условия будет меняться из-за <a data-tooltip-position=\"top\" aria-label=\"Узлы результатов, BranchResultNode\" data-href=\"#Узлы результатов, BranchResultNode\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узлы_результатов,_BranchResultNode_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">доп. действий в неопределенных узлах-результатах</a> внутри тела цикла.В коде данный узел представлен классом WhileCycleNode, и содержит следующую информацию:\nWhileCycleNode.conditionExpr - выражение условия: булево выражение, которое должно выдавать true, если цикл должен продолжаться. WhileCycleNode.thoughtBranch - ветвь мысли, представляющая тело цикла.\nWhileCycleNode.outcomes (наследуется от LinkNode) - переходы к следующим узлам; ключом перехода является результат агрегации вложенных ветвей BranchResult.\nПоведение при прорешивании:\nПока выполяется условие цикла WhileCycleNode.conditionExpr, выполняется тело цикла WhileCycleNode.thoughtBranch.\nЕсли очередная итерация завершилась с результатом true или false, то этот результат считается итоговым, и цикл завершается. Иначе если WhileCycleNode.conditionExpr не выполняется (выдает false), то цикл считается завершенным с результатом null.\nЕсли у данного узла есть переход с ключом, соответствующим полученному результату, то решение переходит к узлу, соответствующему данному переходу. Иначе текущая ветвь мысли считается завершенной с результатом, соответствующим полученному.\nВалидация:\nВложенные выражения должны быть валидными и соответствовать известной в дереве на данный момент информации.\nТип возвращаемого значения выражения условия цикла WhileCycleNode.conditionExpr должен быть булевым значением.\nПереходы из узла должен содержать переход с ключом null. ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Ветви мысли, ThoughtBranch","level":2,"id":"Ветви_мысли,_ThoughtBranch_0"},{"heading":"Результаты ветвей мысли","level":2,"id":"Результаты_ветвей_мысли_0"},{"heading":"Узлы результатов, BranchResultNode","level":3,"id":"Узлы_результатов,_BranchResultNode_0"},{"heading":"Связующие узлы и переходы между узлами","level":2,"id":"Связующие_узлы_и_переходы_между_узлами_0"},{"heading":"Вопросы","level":2,"id":"Вопросы_0"},{"heading":"Обычный вопрос, QuestionNode","level":3,"id":"Обычный_вопрос,_QuestionNode_0"},{"heading":"Вопрос с кортежем (с несколькими частями), TupleQuestionNode","level":3,"id":"Вопрос_с_кортежем_(с_несколькими_частями),_TupleQuestionNode_0"},{"heading":"Действия","level":2,"id":"Действия_0"},{"heading":"Действие поиска (найти объект и запомнить), FindActionNode","level":3,"id":"Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0"},{"heading":"Другие действия","level":3,"id":"Другие_действия_0"},{"heading":"Агрегация и узлы агрегации","level":2,"id":"Агрегация_и_узлы_агрегации_0"},{"heading":"Узел агрегации по ветвям, BranchAggregationNode","level":3,"id":"Узел_агрегации_по_ветвям,_BranchAggregationNode_0"},{"heading":"Узел агрегации в цикле по объектам, CycleAggregationNode","level":3,"id":"Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0"},{"heading":"Узел последовательной агрегации, WhileCycleNode","level":3,"id":"Узел_последовательной_агрегации,_WhileCycleNode_0"}],"links":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_последовательной_агрегации,_WhileCycleNode_0","1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_в_цикле_по_объектам,_CycleAggregationNode_0","1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узел_агрегации_по_ветвям,_BranchAggregationNode_0","1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Действие_поиска_(найти_объект_и_запомнить),_FindActionNode_0","1.-модели-(its_domainmodel)/дерево-решений/узлы.html#Узлы_результатов,_BranchResultNode_0"],"author":"","coverImageURL":"images/nodes_branchresultnode.png","fullURL":"1.-модели-(its_domainmodel)/дерево-решений/узлы.html","pathToRoot":"../..","attachments":["images/nodes_branchresultnode.png","images/nodes_questionnode.png","images/nodes_tuplequestionnode.png","images/nodes_findactionnode.png","images/nodes_sim_and.png","images/nodes_sim_or.png","images/nodes_mutex.png","images/nodes_hyp.png","images/nodes_seq.png","images/nodes_branchaggregationnode.png","images/nodes_cycleaggregationnode.png","images/nodes_whilecyclenode.png"],"createdTime":1755797001907,"modifiedTime":1755895710120,"sourceSize":40385,"sourcePath":"1. Модели (its_DomainModel)/Дерево решений/Узлы.md","exportPath":"1.-модели-(its_domainmodel)/дерево-решений/узлы.html","showInTree":true,"treeOrder":4,"backlinks":["2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html":{"title":"Словари + RDF","icon":"","description":"WIP\nЭта статья является \"скелетом\" и еще не дописана.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":[],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","pathToRoot":"../../..","attachments":[],"createdTime":1755797001914,"modifiedTime":1756111246319,"sourceSize":109,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Представления данных/Словари + RDF.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","showInTree":true,"treeOrder":7,"backlinks":["1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html":{"title":"LOQI","icon":"","description":"LOQI - это специально созданный для данного проекта текстовый язык записи данных, хранимых <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области\" data-href=\"Модель предметной области\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">моделью предметной области</a>.Note\nПоскольку это кастомный язык, в блоках кода с его описанием будет использоваться подсветка для языка Dart - просто потому что она относительно неплохо подходит.\nПример записи на LOQI://класс \"Питомец\"\nclass Pet { //\"Возраст\" - Объектное свойство данного класса obj prop age: int;\n} //класс \"Человек\"\nclass Human { //\"Возраст\" - Объектное свойство данного класса obj prop age: int; //\"Имеет питомца\" - отношение между объектами класса \"Человек\" // и объектами класса \"Питомец\" rel hasPet(Pet) : {1 -&gt; *} ;\n} //Объект класса \"Питомец\", представляющий конкретного питомца \"Мурзик\"\nobj murzik : Pet { //Утверждение о значении свойства \"Возраст\" данного объекта age = 2;\n} //Объект класса \"Человек\", представляющий конкретного человека \"Алиса\"\nobj alice : Human { //Утверждение о значении свойства \"Возраст\" данного объекта age = 22; //Утверждение о связи данного объекта //с другим объектом \"Мурзик\" по отношению \"имеет питомца\" hasPet(murzik);\n}\nLOQI был создан из-за трудности чтения RDF-записей, а также из-за их неспособности описать определения данных (в RDF записываются только утверждения).Note\nТехнически, можно было бы придумать, как записывать в RDF все те же данные, что и в LOQI, но это бы требовало большого усложнения и без того трудночитаемых конструкций.\nТем не менее, подобная необходимость еще может возникнуть, например, чтобы оптимизировать графовые операции над моделью предметной области. LOQI написан на ANTLR4. В коде его грамматику можно посмотреть в файле LoqiGrammar.g4.\nLOQI не имеет значимых пробелов (whitespaces) - это значит, что, в теории, любую модель можно записать в одну (длинную и сложночитаемую) строку\nФайлы LOQI имеют расширение .loqi. (Но, строго говоря, это ни на что не влияет - можете скормить в парсер хоть .txt)\n<br>Т.к. LOQI был создан специально для представления <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области\" data-href=\"Модель предметной области\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">модели предметной области</a> в тексте, то он поддерживает весь функционал, предоставляемый моделью. Поэтому для хранения, обмена, и отладки модели рекомендуется использовать именно LOQI - т.к. он полностью отображает сохраняемую в модели информацию. <br>Единственным (незначительным) исключением из этого правила являются <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданные</a> - поскольку в коде в них можно положить произвольные значения (т.е. любые объекты). Запись метаданных в LOQI поддерживает только те типы данных, <a data-tooltip-position=\"top\" aria-label=\"Свойства > Типы значений свойств\" data-href=\"Свойства#Типы значений свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Типы значений свойств\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">которые могут иметь свойства</a>. Работа с LOQI в коде представлена пакетом its.model.definition.loqi.По сути, LOQI представляет собой только механизм сериализации и десериализации модели DomainModel.Для десериализации (преобразование LOQI текста в объект DomainModel) используйте класс DomainLoqiBuilder, а точнее его статический метод DomainLoqiBuilder.buildDomain(). Данный метод принимает объект Reader, что позволяет считывать данные из произвольных мест - например, из строки в коде, из файла, или из ресурсов приложения.\nПримеры использования://Чтение из строки\nDomainModel modelA = DomainLoqiBuilder.buildDomain(new StringReader(loqiString)); //Чтение из файла\nDomainModel modelB = DomainLoqiBuilder.buildDomain(new FileReader(\"domain.loqi\")); //Чтение из ресурсов приложения\nDomainModel modelC = DomainLoqiBuilder.buildDomain(new InputStreamReader( this.getClass().getClassLoader().getResource(\"domain.loqi\").openStream() ));\nДля сериализации (преобразование объекта DomainModel в LOQI текст) используйте класс DomainLoqiWriter, а точнее его статический метод DomainLoqiWriter.saveDomain().\nДанный метод принимает саму модель DomainModel, а также объект Writer, что позволяет записывать данные в произвольные места: например, в отдельную строку-буфер или в файл.<br>Note\nДанный метод также принимает третий аргумент - набор так называемых опций записи. Они немного изменяют итоговый вид LOQI-текста (подробнее см. в коде), но эти изменения незначительны, и связаны с редко используемым функционалом, который мы рассмотрим <a data-tooltip-position=\"top\" aria-label=\"Свободные данные\" data-href=\"#Свободные данные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Свободные_данные_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">в конце данной статьи</a>.\nВ большинстве случаев третий аргумент стоит оставлять как пустой набор.\nПримеры использования://Запись в строку\nStringWriter stringWriter = new StringWriter(); DomainLoqiWriter.saveDomain(domainModel, stringWriter, Set.of()); String loqiString = stringWriter.toString(); //Запись в файл\nDomainLoqiWriter.saveDomain(domainModel, new FileWriter(\"domain.loqi\"), Set.of());\nДалее в этой статье будут рассмотрены детали записи языка и его спецификация.LOQI поддерживает однострочные (// ...) и многострочные (/* ... */) комментарии, которые не преобразовываются в модель, и нужны просто для человеческого понимания.Все сущности в LOQI имеют некоторое закрепленное за ними имя. Здесь и далее подобные имена будут технически называться идентификаторами.Идентификатор может иметь две формы:\nПростой идентификатор - строка, соответствующая регулярному выражению [a-zA-Z$_][a-zA-Z$_0-9]*. Подобные идентификаторы весьма распространены во многих языках программирования - это строка, содержащая буквы, цифры, а также знаки $ и _, но не начинающаяся с цифры. Имена переменных в Java придерживаются тех же правил.\nОбратите внимание, что простой идентификатор не может пересекаться с ключевым словом LOQI. Например, в LOQI записи не может существовать идентификатор true или идентификатор class. Произвольный или экранированный идентификатор - строка, соответствующая регулярному выражению `\\W+` Т.е. это произвольная непустая строка без пробелов, окруженная символами ` (символ backtick, бэктик)\nЭкранированные идентификаторы позволяют большую свободу в названиях ваших сущностей, в том числе допускаются пересечения с ключевыми словами - например, может существовать идентификатор `true` или идентификатор `class`.\nОбратите внимание, что при переводе в Java-объекты экранированные идентификаторы \"разворачиваются\": в коде строка, соответствующая LOQI идентификатору `class`, будет иметь просто значение class . В связи с этим, например, идентификаторы `Name` и Name будут эквивалентны. Note\nЭто не жесткое правило синтаксиса LOQI, но разные идентификаторы стоит записывать по разному, для понятности.\nПредлагаемые автором конвенции: <br>Для <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"#Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Классы_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классов</a>: PascalCase\n<br>Для <a data-tooltip-position=\"top\" aria-label=\"Перечисления (Enum)\" data-href=\"#Перечисления (Enum)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Перечисления_(Enum)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">перечислений</a>: PascalCase\n<br>Для значений <a data-tooltip-position=\"top\" aria-label=\"Перечисления (Enum)\" data-href=\"#Перечисления (Enum)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Перечисления_(Enum)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">перечислений</a>: MACRO_CASE\n<br>Для <a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"#Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Объекты_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объектов</a>: camelCase\n<br>Для <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"#Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойств</a> и <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"#Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Отношения_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношений</a>: camelCase В различных местах языка также может упоминаться список идентификаторов. Чаще всего это подразумевает запись произвольного кол-во идентификаторов, разделенных запятой , (также допускается запятая в конце)&lt;идентификатор1&gt; , &lt;идентификатор2&gt; ... [,]\nЗдесь и далее в подобных записях синтаксиса квадратными скобками [] обозначены необязательные участки.Под значениями понимаются конкретные литералы различных типов, используемых в разных местах языка.<br>Запись в LOQI использует значения тех типов, <a data-tooltip-position=\"top\" aria-label=\"Свойства > Типы значений свойств\" data-href=\"Свойства#Типы значений свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Типы значений свойств\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">которые могут иметь свойства</a>.Строка вида &lt;идентификатор перечисления&gt;:&lt;идентификатор значения&gt;.\nПримеры: State:EVALUATED, Position:LEFT.Последовательность десятичных цифр, не начинающаяся с нуля (за исключением самого числа 0).\nПримеры: 0, 9, 1024.\nЦелые числа с суффиксом d или D на конце. Примеры: 0d, 9D, 1024d\nДесятичная дробь, разделенная точкой .. Целая часть может отсутствовать (считается равной нулю). Примеры: 0.0, 0.05, .05, 100.75\nЦелые числа или десятичные дроби с экспоненциальной частью вида e&lt;число&gt; или E&lt;число&gt;. Примеры: 1e7, 0.5E10, 5e-2\ntrue или false\nОднострочный текст, обернутый в кавычки \"...\" либо одинарные кавычки '...' В строке допускаются эскейп-последовательности \\n, \\t, \\r, \\b, \\f, \\', \\\" и \\\\, а также неэкранированные кавычки \"противоположного\" типа Многострочный текст, обернутый в троекратные кавычки \"\"\"...\"\"\" либо троекратные одинарные кавычки '''...''' В строках допускаются эскейп-последовательности (см. выше), переносы строки, а также неэкранированные кавычки \"противоположного\" типа <br>Объявление <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданных</a> в LOQI имеет одинаковый для разных сущностей синтаксис, следующего вида:[ &lt;свойство метаданных&gt;*\n]\nЗдесь и далее в подобных записях синтаксиса звездочкой `обозначено произвольное количество сооветствующих участков (включая 0).* ***Конкретно в данном случае квадратные скобки[]` не обозначают необязательность, а являются элементом синтаксиса.***&lt;свойство метаданных&gt; имеет форму[&lt;идентификатор кода локализации&gt; . ] &lt;идентификатор свойства метаданных&gt; = &lt;значение&gt; ;\nТаким образом, пример записи метаданных может быть таким:[ index = 0 ; RU.localizedName = \"операнд _Char_value на позиции 1\" ; EN.localizedName = \"variable _Char_value at position 1\" ;\n]\nВ дальнейших секциях запись метаданных поясняться не будет, поскольку она везде такая, как это написано здесь.<br>Объявление <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">класса</a> в LOQI имеет следующий синтаксис:class &lt;идентификатор класса&gt; [: &lt;идентификатор родительского класса&gt;] [&lt;тело класса&gt;]\n[&lt;метаданные класса&gt;]\n&lt;тело класса&gt; имеет форму{ &lt;данные о классе&gt;* }\nПри этом &lt;данные о классе&gt; могут включать в себя:\n<br><a data-tooltip-position=\"top\" aria-label=\"Объявления отношений\" data-href=\"#Объявления отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Объявления_отношений_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Объявления отношений</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"Объявления свойств\" data-href=\"#Объявления свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Объявления_свойств_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Объявления свойств</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"Утверждения о значениях свойств\" data-href=\"#Утверждения о значениях свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Утверждения_о_значениях_свойств_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Утверждения о значениях свойств</a>\nТаким образом, пример записи класса может быть таким:class Operator : Element { //... данные о классе ...\n} [ //... метаданные ...\n]\nИли таким:class Element //и все!\n<br>Объявление <a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объекта</a> в LOQI имеет следующий синтаксис:obj &lt;идентификатор объекта&gt; : &lt;идентификатор класса объекта&gt; [&lt;тело объекта&gt;]\n[&lt;метаданные объекта&gt;]\n&lt;тело объекта&gt; имеет форму{ &lt;данные об объекте&gt;* }\nПри этом &lt;данные об объекте&gt; могут включать в себя:\n<br><a data-tooltip-position=\"top\" aria-label=\"Утверждения о связях по отношениям\" data-href=\"#Утверждения о связях по отношениям\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Утверждения_о_связях_по_отношениям_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Утверждения о связях по отношениям</a>\n<br><a data-tooltip-position=\"top\" aria-label=\"Утверждения о значениях свойств\" data-href=\"#Утверждения о значениях свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Утверждения_о_значениях_свойств_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Утверждения о значениях свойств</a>\nТаким образом, пример записи объекта может быть таким:obj alice : Human { //... данные об объекте ...\n} [ //... метаданные ...\n]\nИли таким:obj murzik : Pet //и все!\n<br>Объявление <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношения</a> в LOQI имеет следующий синтаксис:rel &lt;идентификатор отношения&gt;(&lt;список идентификаторов классов объектов отношения&gt;) [: &lt;вид отношения&gt;] [&lt;метаданные отношения&gt;] ;\n<br>&lt;вид отношения&gt; указывает на <a data-tooltip-position=\"top\" aria-label=\"Отношения > Характеристики отношений\" data-href=\"Отношения#Характеристики отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Характеристики отношений\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">соответствующую характеристику</a> данного отношения, и может иметь две формы: &lt;независимый вид отношения&gt; и &lt;зависимый вид отношения&gt;\nВ отсутствии указания вида отношения, оно считается независимым, не задающим шкалу, и не имеющим квантификатора. &lt;независимый вид отношения&gt; имеет следующий синтаксис:&lt;тип шкалы отношения&gt;\nИЛИ\n&lt;квантификатор отношения&gt;\nИЛИ\n&lt;тип шкалы отношения&gt; &lt;квантификатор отношения&gt;\nЗдесь <br>&lt;тип шкалы отношения&gt; это либо linear для обозначения линейной шкалы, либо partial для обозначения частичной шкалы. Подробнее про шкалы <a data-tooltip-position=\"top\" aria-label=\"Отношения > Шкала\" data-href=\"Отношения#Шкала\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Шкала\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">здесь</a>\n<br>&lt;квантификатор отношения&gt; это строка вида { subjCount -&gt; objCount }, где subjCount и objCount это либо целые числа, либо звездочка *. Подробнее про квантификаторы <a data-tooltip-position=\"top\" aria-label=\"Отношения > Количественность (Квантификатор)\" data-href=\"Отношения#Количественность (Квантификатор)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Количественность (Квантификатор)\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">здесь</a>\n&lt;зависимый вид отношения&gt; имеет следующий синтаксис:&lt;тип зависимости&gt; to &lt;ссылка на основное отношение&gt;\nЗдесь\n<br>&lt;тип зависимости&gt; это одна из следующих строк, обозначающая соответствующий <a data-tooltip-position=\"top\" aria-label=\"Отношения > Типы зависимых отношений\" data-href=\"Отношения#Типы зависимых отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типы зависимых отношений\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">тип зависимости</a> отношения от другого основного отношения: opposite\ntransitive\nbetween\ncloser\nfurther &lt;ссылка на основное отношение&gt; может иметь две формы: Идентификатор отношения, если ссылаемся на отношение в том же классе\nСтрока вида &lt;идентификатор класса&gt; -&gt; &lt;идентификатор отношения&gt; , если ссылаемся на отношение в другом классе Примеры различных объявлений отношений://Независимое отношение со шкалой и квантификатором\nrel isDirectlyLeftOf(Token) : linear {1 -&gt; 1} [ //... метаданные ...\n] ; //Независимое отношение со шкалой\nrel isOperandOf(Element) : partial ; //Простое независимое отношение\nrel belongsTo(Element) ; //Зависимое отношение со ссылкой на отношение другого класса\nrel has(Token) : opposite to Token-&gt;belongsTo ; //Независимосе тернарное отношение (2 класса объектов)\nrel isComplexOperandWith(Token, Token,) ;\nУтверждение о связи объектов по отношению имеет следующий синтаксис:&lt;идентификатор отношения&gt;(&lt;список идентификаторов объектов отношения&gt;) ;\nНапример://бинарная связь\nbelongsTo(element_1); //тернарная связь\nisComplexOperandWith(tokenA, tokenB);\n<br>Объявление <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойства</a> в LOQI имеет следующий синтаксис:&lt;вид свойства&gt; prop &lt;идентификатор свойства&gt; : &lt;тип свойства&gt; [&lt;метаданные свойства&gt;] ;\n<br>&lt;вид свойства&gt; это либо class для обозначения классового свойства, либо obj для обозначения объектного свойства. Подробнее о видах свойств <a data-tooltip-position=\"top\" aria-label=\"Свойства > Объектные и классовые свойства\" data-href=\"Свойства#Объектные и классовые свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">здесь</a>&lt;тип свойства&gt; может иметь следующие формы:\n&lt;идентификатор перечисления&gt; - перечислимый тип\nint &lt;диапазон целых чисел&gt; - целочисленный тип &lt;диапазон целых чисел&gt; показывает допустимые значения в данном типе, и имеет одну из следующих форм: строка вида [a, b], показывающая диапазон-промежуток от целого числа a до целого числа b, включительно. При этом как a, так и b могут быть опущены - в таком случае считается, что у промежутка нет верхней и нижней границы соответственно.\nстрока вида {a, b, c ... }, показывающая диапазон-множество конкретных допустимых значений, где a, b, c и т.д. - целые числа double &lt;диапазон дробных чисел&gt; - дробночисленный тип &lt;диапазон дробных чисел&gt; - аналогично &lt;диапазон целых чисел&gt; выше, но указываемые значения могут быть как целыми, так и дробными. bool - тип булево значение\nstring - строковый тип\nПримеры различных объявлений свойств://объектное свойство перечислимого типа, с метаданными\nobj prop state : State [ //... метаданные ...\n] ; //классовое свойство целочисленного типа с диапазоном-множеством\nclass prop countOfTokens : int{1, 2} ; //объектное свойство дробного типа с диапазоном-промежутком obj prop probablity : double[0.0, 1.0] Утверждение о значении свойства в LOQI имеет следующий синтаксис:&lt;идентификатор свойства&gt; = &lt;значение&gt; ;\nНапример:countOfTokens = 2; probablity = 0.7; state = State:UNEVALUATED;\nВ случае классовых свойств для краткости записи можно также одновременно и объявить свойство, и задать ему значение для текущего класса.\nПодобная запись имеет следующий синтаксис:&lt;вид свойства&gt; prop &lt;идентификатор свойства&gt; [: &lt;тип свойства&gt;] = &lt;значение&gt; [&lt;метаданные своства&gt;] ;\nНапример следующая запись:class prop countOfTokens : int{1, 2} = 2;\nЭквивалентна следующим:class prop countOfTokens : int{1, 2} ;\ncountOfTokens = 2;\nТакже, как видно по синтаксису, тип свойства в данном случае можно опустить - он определяется на основе присваемого значения (но для числовых типов диапазон определяться не будет).Например://свойство имеет тип int, определенный по значению\nclass prop countOfTokens = 2;\n<br>Объявление <a data-tooltip-position=\"top\" aria-label=\"Перечисления (Enum)\" data-href=\"Перечисления (Enum)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">перечисления</a> в LOQI имеет следующий синтаксис:enum &lt;идентификатор перечисления&gt; [&lt;тело перечисления&gt;]\n[&lt;метаданные перечисления&gt;]\n&lt;тело перечисления&gt; имеет следующую форму:{ &lt;список значений перечисления&gt;\n}\nЗдесь &lt;список значений перечисления&gt; подразумевает запись произвольного кол-во значений перечисления, разделенных запятой , (также допускается запятая в конце)&lt;значение перечисления 1&gt; , &lt;значение перечисления 2&gt; ... [,]\n&lt;значение перечисления&gt; имеет следующий синтаксис:&lt;идентификатор значения перечисления&gt; [&lt;метаданные значения перечисления&gt;]\nТаким образом, пример записи перечисления может быть таким:enum State { UNEVALUATED [ //... метаданные ... ], EVALUATED [ //... метаданные ... ], USED [ //... метаданные ... ], OMITTED [ //... метаданные ... ], } [ //... метаданные ...\n]\nИли таким:enum State { UNEVALUATED, EVALUATED, USED, OMITTED }\nИли таким:enum State\n(хотя не особо понятно, зачем может пригодиться перечисление без значений)\"Свободные\" данные - это концепт, который был придуман для возможности хранить метаданные и значения свойств отдельно от их определений - например, метаданные можно было бы выделить в отдельный файл с локализацией, а значения свойств - в теги.<br>С момента их ввода уже появилась <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области > Составление модели из частей\" data-href=\"Модель предметной области#Составление модели из частей\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Составление модели из частей\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">возможность объединять несколько различных моделей</a>, что по сути приводит к тем же возможностям, в связи с чем этот функционал практически не используется.\n(Но справедливости ради, \"свободные данные\" позволяют разделить информацию даже внутри одного LOQI файла, в то время как объединение моделей этого не позволяет)Тем не менее, данный функционал присутствует в системе, поэтому для полноты он будет описан.Свободные метаданные - это возможность определить метаданные сущности отдельно от ее основного объявления.\nЭта конструкция имеет следующий синтаксис:meta for &lt;ссылка на сущность&gt; &lt;метаданные для сущности&gt;\nЗдесь &lt;ссылка на сущность&gt; может иметь следующие формы:\n[obj] &lt;идентификатор объекта&gt; для ссылки на объект\nclass &lt;идентификатор класса&gt; для ссылки на класс\n&lt;идентификатор класса&gt;.&lt;идентификатор свойства&gt; для ссылки на свойство\n&lt;идентификатор класса&gt; -&gt; &lt;идентификатор отношения&gt; для ссылки на отношение\nenum &lt;идентификатор перечисления&gt; для ссылки на перечисление\n&lt;идентификатор перечисления&gt;:&lt;идентификатор значения&gt; для ссылки на значение перечисления\nНапример:meta for State:EVALUATED [ RU.localizedName = \"вычислен\" ; EN.localizedName = \"evaluated\" ;\n]\nСвободные значения свойств классов - это возможность задать значения свойствам класса отдельно от его основного определения.\nЭта конструкция имеет следующий синтаксис:values for class &lt;идентификатор класса&gt; { &lt;утверждения о значении свойства&gt;*\n}\nНапример:values for class `operator_&amp;&amp;` { arity = Arity:BINARY ; precedence = 14 ; associativity = Associativity:LEFT ; needsLeftOperand = true ; needsRightOperand = true ; needsInnerOperand = false ; countOfTokens = 1 ;\n}\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общая информация о языке","level":2,"id":"Общая_информация_о_языке_0"},{"heading":"Работа с LOQI в коде","level":2,"id":"Работа_с_LOQI_в_коде_0"},{"heading":"Комментарии","level":2,"id":"Комментарии_0"},{"heading":"Идентификаторы (Имена)","level":2,"id":"Идентификаторы_(Имена)_0"},{"heading":"Значения","level":2,"id":"Значения_0"},{"heading":"Значения перечислений","level":3,"id":"Значения_перечислений_0"},{"heading":"Целые числа","level":3,"id":"Целые_числа_0"},{"heading":"Дробные числа","level":3,"id":"Дробные_числа_0"},{"heading":"Булевы значения","level":3,"id":"Булевы_значения_0"},{"heading":"Строки","level":3,"id":"Строки_0"},{"heading":"Метаданные","level":2,"id":"Метаданные_0"},{"heading":"Классы","level":2,"id":"Классы_0"},{"heading":"Объекты","level":2,"id":"Объекты_0"},{"heading":"Отношения","level":2,"id":"Отношения_0"},{"heading":"Объявления отношений","level":3,"id":"Объявления_отношений_0"},{"heading":"Утверждения о связях по отношениям","level":3,"id":"Утверждения_о_связях_по_отношениям_0"},{"heading":"Свойства","level":2,"id":"Свойства_0"},{"heading":"Объявления свойств","level":3,"id":"Объявления_свойств_0"},{"heading":"Утверждения о значениях свойств","level":3,"id":"Утверждения_о_значениях_свойств_0"},{"heading":"Одновременное объявление и утверждение","level":3,"id":"Одновременное_объявление_и_утверждение_0"},{"heading":"Перечисления (Enum)","level":2,"id":"Перечисления_(Enum)_0"},{"heading":"Свободные данные","level":2,"id":"Свободные_данные_0"},{"heading":"Свободные метаданные","level":3,"id":"Свободные_метаданные_0"},{"heading":"Свободные значения свойств классов","level":3,"id":"Свободные_значения_свойств_классов_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Типы значений свойств","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Свободные_данные_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Классы_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Перечисления_(Enum)_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Перечисления_(Enum)_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Объекты_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Свойства_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Отношения_0","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Типы значений свойств","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Объявления_отношений_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Объявления_свойств_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Утверждения_о_значениях_свойств_0","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Утверждения_о_связях_по_отношениям_0","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html#Утверждения_о_значениях_свойств_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Характеристики отношений","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Шкала","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Количественность (Квантификатор)","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типы зависимых отношений","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html#Составление модели из частей"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","pathToRoot":"../../..","attachments":[],"createdTime":1755797001914,"modifiedTime":1755895710170,"sourceSize":31856,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Представления данных/LOQI.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","showInTree":true,"treeOrder":8,"backlinks":["1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html":{"title":"Классы","icon":"","description":"Классы представляют собой категории/типы сущностей (<a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объектов</a>), которые могут присутствовать в предметной области. Классы определяют, какие <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойства</a> присущи их объектам, а также какими <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношениями</a> они могут связаны.Пример класса://Класс с именем \"Element\"\nclass Element { //Свойство класса, с именем \"countOfTokens\" и типом int в диапазоне 1-2 class prop countOfTokens: int[1,2] ; //Свойство объектов класса, с именем state и типом State (это enum) obj prop state: State ; //Отношение, которую могут иметь объекты класса с именем \"has\", // связывает объекты данного класса с объектами типа Token как \"один-ко-многим\" rel has(Token) : {1 -&gt; *} ;\n} В коде классы представлены классом ClassDef.\nСостав базовой хранимой информации:\nИмя класса (ClassDef.name)\n<br>Имя <a data-tooltip-position=\"top\" aria-label=\"Наследование\" data-href=\"#Наследование\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html#Наследование_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">родительского</a> класса (ClassDef.parentName)\nОпределяемый данным классом набор свойств (ClassDef.declaredProperties)\n<br>Определенные для класса <a data-tooltip-position=\"top\" aria-label=\"Свойства > Объектные и классовые свойства\" data-href=\"Свойства#Объектные и классовые свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">значения свойств</a> (ClassDef.definedPropertyValues)\nОпределяемый данным классом набор отношений (ClassDef.declaredRelationships)\n<br>Связанные с классом <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданные</a> (ClassDef.metadata)\nПодобно классам в ООП языках, классы в нашей модели домена могут указывать родительский класс, от которого они наследуются (поля ClassDef.parentClassName и ClassDef.parentClass). Такой класс может быть только один - множественное наследование в системе не поддерживается.//Родительский класс Animal, имеет свойство age\nclass Animal { obj prop age: int[0, 100] ;\n} //Дочерний класс Pet, наследуется от Animal\n//имеет свойство родительского класса, а также добавляет свое свойство и отношения\nclass Pet : Animal { obj prop name: string ; rel hasOwner(Human) {* -&gt; 1} ;\n}\nВ случае наследования, дочерний класс получает все свойства и отношения, определенные в его родителе (и родителях родителя).В общем, стандартная модель наследования ООП классов, знакомая из, например, Java (за исключением правил наследования классовых свойств)Корректность класса состоит из:\n<br><a data-tooltip-position=\"top\" aria-label=\"Свойства > Корректность данных (валидация)\" data-href=\"Свойства#Корректность данных (валидация)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Корректность_данных_(валидация)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Корректности всех объявлений и значений свойств</a>;\n<br><a data-tooltip-position=\"top\" aria-label=\"Отношения > Корректность данных (валидация)\" data-href=\"Отношения#Корректность данных (валидация)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Корректность_данных_(валидация)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Корректности всех объявлений отношений</a>;\nА также собственной корректности класса, описанной ниже.\nВ случае указания родительского класса, он должен присутствовать в модели.В цепочке наследования класса не должно быть рекурсии (т.е. класс не может быть дочерним/родительским для самого себя).","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Наследование","level":2,"id":"Наследование_0"},{"heading":"Корректность данных (валидация)","level":2,"id":"Корректность_данных_(валидация)_0"},{"heading":"Полнота","level":3,"id":"Полнота_0"},{"heading":"Валидность","level":3,"id":"Валидность_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html#Наследование_0","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Корректность_данных_(валидация)_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Корректность_данных_(валидация)_0"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001909,"modifiedTime":1755895710130,"sourceSize":4318,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Классы.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","showInTree":true,"treeOrder":9,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html":{"title":"Метаданные","icon":"","description":"Метаданные - это набор произвольных данных, которые можно привязать к определениям в модели предметной области. Метаданные не считаются основной частью модели, и не взаимодействуют с основным функционалом системы. Они нужны в первую очередь для работы с элементами модели предметной области в стороннем коде, которому требуется хранить и использовать некоторые дополнительные данные, не связанные напрямую с данными модели.\nОдним из главных подобных использований является хранение текстовой информации об элементах модели на естественном языке. С учетом частого возникновения подобной необходимости, метаданные поддерживают локализацию.Пример использования метаданных://Предположим, что мы хотим хранить с помощью модели // представление какого-то графа, состоящего из узлов и связей.\n//Тогда, для его графического отображения, нам могут понадобиться доп. данные: //Класс \"Узел\"\nclass GraphNode { //Отношение \"Имеет связь с с другим узлом\" rel isLinkedTo(GraphNode) ;\n} //Первый узел\nobj node_1 : GraphNode { isLinkedTo(node_2);\n} [ //Метаданные, привязанные к объекту: color = \"#0000FF\"; //Цвет узла, как строка size = 20; //Визуальный размер узла, как число RU.text = \"Первый узел\";\t//Локализованные метаданные - текст на русском EN.text = \"First node\"; //Локализованные метаданные - текст на английском\n] //Второй узел\nobj node_2 : GraphNode [ //Аналогично color = \"#00FF00\"; id = 25; RU.text = \"Второй узел\"; EN.text = \"Second node\";\n]\nВ коде метаданные представлены классом MetaData. Подробнее о нем и его структуре в разделе ниже.Привязать метаданные можно к любому объекту, реализующему интерфейс MetaOwner.\nТакими являются:\nБольшинство определений в модели предметной области <a data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Классы</a> (ClassDef)\n<br><a data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Объекты</a> (ObjectDef)\n<br><a data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Свойства</a> (PropertyDef)\n<br><a data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Отношения</a> (RelationshipDef)\n<br><a data-tooltip-position=\"top\" aria-label=\"Перечисления (Enum)\" data-href=\"Перечисления (Enum)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Перечисления</a> (EnumDef)\n<br>Значения <a data-tooltip-position=\"top\" aria-label=\"Перечисления (Enum)\" data-href=\"Перечисления (Enum)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">перечислений</a> (EnumValueDef) Большинство элементов дерева решений (Узлы и некоторые вспомогательные сущности)\nВ простом случае метаданные представляют собой простую мапу \"ключ-значение\", где ключ это некоторая строка название свойства метаданных, а значение может быть произвольного типа (при использовании в коде в метаданные можно положить любые значения).\nПоложить и получить данные в таких случаях можно соответственно методами MetaData.add(name: String, value: Any) и MetaData.get(name: String) .Однако, с учетом необходимости локализации некоторых значений, ключом по факту является пара строк:\nКод локализации - в типичном использовании строка типа \"RU\" или \"EN\", представляющая используемую локализацию. Может быть равен null для нелокализованных метаданных.\nНазвание свойства метаданных. Не может быть равно null\nВ данном случае используются методы MetaData.add(locCode: String?, name: String, value: Any) и MetaData.get(locCode: String?, name: String) соответственно.Хранится все это в \"двухярусной\" мапе:private val propertyNamesToLocalizations = mutableMapOf&lt;String, MutableMap&lt;String?, Any&gt;&gt;()\nЗдесь ключом к внешней мапе является как раз название свойства, а к внутренней - код локализации. Таким образом, разные локализации одного и того же свойства хранятся \"рядом\", в одной внутренней мапе - их все можно получить методом MetaData.getLocalizations(). ","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Хранение и использование данных","level":2,"id":"Хранение_и_использование_данных_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001910,"modifiedTime":1755895710143,"sourceSize":5549,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Метаданные.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","showInTree":true,"treeOrder":10,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html":{"title":"Модель предметной области","icon":"","description":"В данном разделе описывается представление данных, составляющих описание предметной области (домена), и конкретной задачи в них.\nДанный раздел соответствует пакету its.model.definition в кодеОписание предметной области во многом похоже на описание предметной области в любом ООП-языке: для задач выделяются отдельные типы сущностей, которые могут в них присутствовать - <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классы</a>. Классы определяют возможное состояние <a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объектов</a>, относящихся к данному классу - их <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойства</a>, а также какие <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношения</a> могут существовать между ними.\nОбъединение всех этих данных представляется классом DomainModel.Подробнее об отдельных элементах модели домена (выделенных выше ссылками) можно прочитать в отдельных страницах данного разделаПоскольку данная библиотека определяет свои собственные классы для представления данных, с которыми она работает, то в теории она независима от конкретных форматов записи этих данных: при желании, любой, использующий библиотеку, может написать собственный считыватель/преобразователь данных, который бы создавал и заполнял конкретный объект DomainModel (для этого рекомендуется использовать методы класса DomainBuilderUtils).Тем не менее, библиотека предоставляет два способа чтения/записи данных \"из коробки\":\n<br><a data-href=\"LOQI\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">LOQI</a> - собственный специальный язык текстовой записи данных, максимально приближенный к представлению данных в коде. Он создан, чтобы легко вручную читать и писать эти данные.\n<br><a data-href=\"Словари + RDF\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Словари + RDF</a> - формат записи, более приближенный к представлению данных в визуальном редакторе. Здесь, объявления классов/свойств/отношений представляются в табличном виде (т.н. словари, представленные csv файлами), а конкретные утверждения об объектах/значениях/связях записываются в формате RDF.\nNote\nЗдесь и далее в этом разделе для демонстрации данных будет использоваться запись LOQI.\nПоскольку это кастомный язык, в блоках кода с его описанием будет использоваться подсветка для языка Dart - просто потому что она относительно неплохо подходит.\nЭто выглядит так://Класс с именем \"Element\"\nclass Element { //Свойство класса, с именем \"countOfTokens\" и типом int в диапазоне 1-2 class prop countOfTokens: int[1,2] ; //Свойство объектов класса, с именем state и типом State (это enum) obj prop state: State ; //Отношение, которую могут иметь объекты класса с именем \"has\", // связывает объекты данного класса с объектами типа Token как \"один-ко-многим\" rel has(Token) : {1 -&gt; *} ;\n} [ //произвольные локализованные метаданные RU.localizedName = \"элемент\" ; EN.localizedName = \"element\" ;\n]\n<br>Подробнее о самом языке можно почитать в <a data-tooltip-position=\"top\" aria-label=\"LOQI\" data-href=\"LOQI\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">соответствующей статье</a>.В коде вы можете не раз наткнуться на классы-наследники классов DomainDef и DomainRef. Стоит понимать разницу между ними:\nDomainDef (от слова Definition - определение) представляет конкретное определение в модели данных (например, объект или класс) и содержит полную информацию о немDomainRef (от слова Reference - ссылка) представляет только ссылку на соответствующее определение, и содержит только минимально необходимую информацию для того, чтобы найти соответствующее определение в модели домена (для этого класс предоставляет методы findIn и findInOrUnknown).Объявления и Утверждения это понятия, применяемые в основном к свойствам и отношениям в модели домена.\nОбъявления в данном контексте являются информацией о наличии какого-то понятия (свойства/отношения) в модели. Так, например, класс может объявить наличие у него какого-то свойства. Объявления в коде представлены наличием соответствующих DomainDef.\nУтверждения же говорят о некоторых конкретных данных относительно данного понятия - например, значение конкретного свойства у конкретного объекта. Утверждения в коде представлены классами-контейнерами Statements, и их содержимым.Пример:class Element { //Объявление свойства объектов obj prop state: State ; //Объявление отношения между объектами rel has(Token) : {1 -&gt; *} ;\n} obj operator_1 : Element { //Утверждение о значении свойства для конкретного объекта state = State:used ; //Утверждение о связи конкретных объектов по отношению has(token_1) ;\n}\nВ типичных случаях использования модели для описания условия конкретной задачи, модель создается из нескольких частей (от общего к частному):\nОбщая модель предметной области (то, что будет использоваться в деревьях решений)\nМодель с данными для конкретной под-области (т.н. теги)\nМодель с данными для конкретной задачи (чаще всего объекты подключаются именно здесь)\nС учетом такой необходимости, класс DomainModel позволяет свободное объединение и разделение нескольких отдельных моделей:\nDomainModel.add(other: DomainModel) - добавить данные из переданной модели в текущую. В случае наличия дублирований/переопределений в двух моделях, будет выброшена ошибка.\nТ.е. в этом случае определения с одним именем в объединяемых моделях считаются различными, и не могут сосуществовать.\nDomainModel.addMerge(other: DomainModel) - добавить данные из переданной модели в текущую. В отличие от метода add(), переопределения будут объединены, если это возможно.\nТ.е. в этом случае определения с одним именем в объединяемых моделях считаются одним и тем же определением, чья информация \"сливается\" воедино, если только в ней нет противоречий. Возможность данного объединения проверяется методом DomainDef.mergeEquals();\nСама логика объединения описана методом DomainDef.addMerge() DomainModel.subtract(other: DomainModel) - \"вычесть\" данные переданной модели из текущей. Данная операция обратна операции addMerge\nПример объединения моделей:modelAclass MyClass { obj prop intProperty: int ;\n} obj obj_1 : MyClass { intProperty = 100;\n} obj obj_A : MyClass { intProperty = 100;\n}\nmodelBclass MyClass { obj prop boolProp: bool ;\n} obj obj_1 : MyClass { boolProp = true;\n} obj obj_B : MyClass { boolProp = true;\n}\nmodelA, в результате выполнения modelA.addMerge(modelB)class MyClass { obj prop intProperty: int ; obj prop boolProp: bool ;\n} obj obj_1 : MyClass { intProperty = 100; boolProp = true;\n} obj obj_A : MyClass { intProperty = 100;\n} obj obj_B : MyClass { boolProp = true;\n}\nПосле выполнения modelA.subtract(modelB) модель вернется в исходное состояние.Корректность данных в модели выражается в двух составляющих\nПолнота данных - полная известность всех упомянутых в модели сущностей\nВалидность данных - соответствие известных данных наложенным смысловым ограничениям.\nПонимание разницы между этими составляющими важно: неполная модель не может быть использована как источник данных, но она все еще может быть дополнена данными и стать корректной моделью; модель с невалидными данными уже не соответствует требованиям корректности, и никогда не сможет им соответствовать (если только не изменить существующие данные).\nТак, например, в большинстве случаев, модель, построенная из данных о конкретной задаче (см. п.3 в секции выше), будет валидной, но не полной, поскольку в ней отсутствует информация об общей части предметной области - эта информация затем может быть добавлена использованием методов add или addMerge, и модель станет полностью корректна.\nПример неполной модели://Неизвестен класс MyClass\nobj obj_1 : MyClass { //Неизвестно, что за свойство \"property\", и какой тип оно имеет property = 100;\n}\nПример невалидной модели:class MyClass { obj prop property: bool ;\n} obj obj_1 : MyClass { //Свойство известно, но значение не соответствует заявленному типу property = 100;\n}\nВ коде, корректность данных проверяется следующими методами:\nDomainElement.validateAndGet() - проверить валидность модели и получить все найденные ошибки (описания невалидных/неполных данных)\nDomainElement.validateAndThrowInvalid() - проверить модель и выкинуть ошибки, только если есть невалидные данные (неполные данные этим методом игнорируются)\nDomainElement.validateAndThrow() - проверить модель и выкинуть ошибки, только если есть любые некорректные данные (неполные или невалидные)\nПри наполнении модели, данные проверяются на валидность, когда это возможно. В случае прямого добавления в модель невалидных данных, будет выброшена ошибка. Такой выброс ошибки обусловлен политикой fail fast - чем скорее разработчик увидит ошибку, тем лучше.\nОднако невалидность в данных не всегда можно обнаружить сразу (в случаях, когда она зависит от большого количества связанных элементов).\nНеполнота модели же в принципе не может быть обнаружена автоматически в процессе ее наполнения - только разработчик решает, когда модель должна быть закончена, корректна, и готова к использованию.\nВ связи с этим перед использовании модели обязательно нужно вызвать методы валидации из описанных выше (в большинстве случаев подходит наиболее строгий validateAndThrow, но это стоит решать по ситуации)","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Общие принципы","level":2,"id":"Общие_принципы_0"},{"heading":"Представления данных","level":2,"id":"Представления_данных_0"},{"heading":"Общие понятия при работе с моделью","level":2,"id":"Общие_понятия_при_работе_с_моделью_0"},{"heading":"DomainDef и DomainRef","level":3,"id":"DomainDef_и_DomainRef_0"},{"heading":"Объявления и Утверждения","level":3,"id":"Объявления_и_Утверждения_0"},{"heading":"Составление модели из частей","level":2,"id":"Составление_модели_из_частей_0"},{"heading":"Валидация модели","level":2,"id":"Валидация_модели_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001910,"modifiedTime":1755895710155,"sourceSize":15233,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Модель предметной области.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","showInTree":true,"treeOrder":11,"backlinks":["1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html":{"title":"Объекты","icon":"","description":"Объекты представляют собой конкретные сущности, присутствующие в задаче/предметной области. Тогда как <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классы</a> определяют, что может быть в предметной области, конкретное множество и состояние объектов определяет конкретную ситуацию, возникшую в предметной области.<br>\nТак, основной смысл объектов состоит в том, что значения их <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойств</a> и связи их между собой по <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношениям</a> создают описание некоторой конкретной ситуации.Пример использования объектов://класс \"Питомец\"\nclass Pet { obj prop age: int;\n} //класс \"Человек\"\nclass Human { obj prop age: int; rel hasPet(Pet) : {1 -&gt; *} ;\n} //Объект класса \"Питомец\", представляющий конкретного питомца \"Мурзик\"\nobj murzik : Pet { age = 2;\n} //Объект класса \"Человек\", представляющий конкретного человека \"Алиса\"\nobj alice : Human { //конкретные утверждения о значениях свойств и связях между объектами // описывают ситуацию age = 22; hasPet(murzik);\n}\nВ коде классы представлены классом ObjectDef.\nСостав базовой хранимой информации:\nИмя объекта (ObjectDef.name)\n<br>Имя класса, <a data-tooltip-position=\"top\" aria-label=\"Объекты являются экземплярами класса\" data-href=\"#Объекты являются экземплярами класса\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html#Объекты_являются_экземплярами_класса_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">инстансом</a> которого является данный объект (ObjectDef.className)\n<br>Определенные для объекта <a data-tooltip-position=\"top\" aria-label=\"Свойства > Объектные и классовые свойства\" data-href=\"Свойства#Объектные и классовые свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">значения свойств</a> (ObjectDef.definedPropertyValues)\nУтверждения о связях объекта с другими объектами по отношениям (ObjectDef.relationshipLinks)\n<br>Связанные с объектом <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданные</a> (ObjectDef.metadata)\nЛюбой задаваемый в модели объект должен указывать некоторый класс, инстансом (экземпляром) которого он является (поля ObjectDef.className и ObjectDef.clazz). Такой класс может быть только один - множественное наследование в системе не поддерживается.\nОбъект, являющийся инстансом класса, считаются инстансом любого из его родительских классов.От своего класса (а также его родительских классов) объект получает все определенные в них значения классовых свойств, а также получает возможность (и необходимость) иметь значения по всем определенных в них объектных свойствах и быть связанным с другими объектами связями по определенным в них отношениях.\nПодробнее см.:\n<br><a data-href=\"Классы#Наследование\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html#Наследование\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Классы &gt; Наследование</a>\n<br><a data-href=\"Свойства#Объектные и классовые свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Свойства &gt; Объектные и классовые свойства</a>\n<br><a data-href=\"Свойства#Получение значений свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Получение значений свойств\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Свойства &gt; Получение значений свойств</a>\n<br><a data-href=\"Отношения#Типизация отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типизация отношений\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Отношения &gt; Типизация отношений</a>\nКорректность объекта состоит из:\n<br><a data-tooltip-position=\"top\" aria-label=\"Свойства > Корректность данных (валидация)\" data-href=\"Свойства#Корректность данных (валидация)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Корректность_данных_(валидация)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Корректности всех значений его свойств</a>;\n<br><a data-tooltip-position=\"top\" aria-label=\"Отношения > Корректность данных (валидация)\" data-href=\"Отношения#Корректность данных (валидация)\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Корректность_данных_(валидация)_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Корректности всех его связей по отношениям</a>;\nА также собственной корректности объекта, описанной ниже.\nКласс, экземпляром которого является объект, должен присутствовать в модели.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Объекты являются экземплярами класса","level":2,"id":"Объекты_являются_экземплярами_класса_0"},{"heading":"Корректность данных (валидация)","level":2,"id":"Корректность_данных_(валидация)_0"},{"heading":"Полнота","level":3,"id":"Полнота_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html#Объекты_являются_экземплярами_класса_0","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html#Наследование","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные и классовые свойства","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Получение значений свойств","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типизация отношений","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Корректность_данных_(валидация)_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Корректность_данных_(валидация)_0"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001911,"modifiedTime":1755895710158,"sourceSize":4680,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Объекты.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","showInTree":true,"treeOrder":12,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html":{"title":"Отношения","icon":"","description":"Отношения - это описание некоторых связей, которыми могут быть связаны <a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объекты</a>.<br>\nНабор отношений, в которых может участвовать конкретный объект, задается в <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классах</a>, от которых данный объект наследуется.В формулировке выше обратите внимание, что классы не могут быть связаны между собой отношениями - классы только задают возможные отношения, которыми могут быть связаны их объекты.Пример использования отношений//класс \"Питомец\"\nclass Pet //класс \"Человек\"\nclass Human { //Отношение \"имеет питомца\", связывает объекты \"Людей\" с объектами \"Питомцев\" rel hasPet(Pet) : {1 -&gt; *} ;\n} //Кот Бася, питомец\nobj basya : Pet //Человек Юля\nobj yulia : Human { //Юля связана с Басей отношением \"имеет питомца\" hasPet(basya);\n}\nВ коде определения отношений представлены классом RelationshipDef\nСостав базовой хранимой информации:\nИмя отношения (RelationshipDef.name)\nИмя класса-субъекта отношения (RelationshipDef.subjectClassName)\nИмена классов-объектов отношения (RelationshipDef.objectClassNames)\nВид/Характеристика отношения (RelationshipDef.kind)\nУтверждения о конкретной связи объектов по отношению представлены классом RelationshipLinkStatement\nСостав базовой хранимой информации:\nОбъект, из которого исходит связь (субъект связи) (RelationshipLinkStatement.owner)\nИмя отношения (RelationshipLinkStatement.relationshipName)\nИмена связанных объектов (объекты связи) (RelationshipLinkStatement.objectNames)\nNote\nЗдесь и далее в этой статье для записи определений конкретных отношений, будем использовать запись вида SubjClass -&gt; relationship(ObjClass1, ... ObjClassN), где SubjClass и ObjClass1-N - классы.\n(Классы записываем с большой буквы, и используем -&gt;)\nОпределение отношения вида A -&gt; rel(B, C) (где классы A, B и C в общем случае различны) означает, что объекты-инстансы класса А (и только они) могут быть связаны отношением rel с объектами-инстансами классов B и C (и только с ними).\nЭта типизация строга, т.к. нельзя \"запихнуть\" в отношение объекты классов, не подходящие ему по типу. Однако, наличие в системе наследования означает, что любые наследники данных классов могут быть связаны данным отношением.Отношения представляют собой направленные связи между объектами заданных классов. Это значит, что у связи есть конкретный объект-источник (называемый субъектом) и объекты-\"окончания\" (называемые, за неимением лучшего термина, объектами связи).Схематично это можно представить так:<br>\n<img alt=\"relationship_demo.png\" src=\"images/relationship_demo.png\" target=\"_self\">Note\nЗдесь и далее для записи отдельных утверждений о связях между объектами будем использовать запись subj =&gt; relationship(obj1, ..., objN), где subj, и obj1-N - объекты.\n(Объекты записываем с маленькой буквы, и используем =&gt;)\nНа практике направленность отношений выражается в том, что утверждения a =&gt; rel(b) и b =&gt; rel(a) различны.Как можно понять из формулировок выше, в общем случае объектов связи может быть больше одного (сколько угодно), в то время как субъект связи есть только один.\nВ связи с этим, часто возникает необходимость разделять отношения по их \"арности\" - количеству объектов, связанных этих отношением. Соответственно, арность отношения равно кол-ву объектов связи + 1 (субъект связи).\nНаиболее распространены бинарные отношения (\"субъект -&gt; объект\") и тернарные отношения (\"субъект -&gt; два объекта\"). N-арными отношениями называем отношения, чья арность превышает 2 (т.е. все, что больше бинарных)<br>\n<img alt=\"relationship_arity.png\" src=\"images/relationship_arity.png\" target=\"_self\">Поскольку для отношения вида A -&gt; rel(B, C) классы B и C в общем случае различны, то становится очевидно, что для соответствующих утверждений становится значимым порядок указания объектов связи: поскольку утверждение a =&gt; rel(b, c) в таком случае валидно, а утверждение a =&gt; rel(c, b) - невалидно, т.к. не соответствует типизации (если предполагать что a, b и c это объекты-инстансы классов A, B и C соответственно). Таким образом, отношения, чьи классы-объекты различны, считаются упорядоченными - в записи утверждений о них важен порядок объектов связи.\nУпорядоченными также считаются отношения некоторых зависимых типов (см. ниже) - например \"Ближе к чем\" и \"Дальше от чем\".В противном случае отношение считается считается неупорядоченным (если отношение задано так, что все его объекты имеют один и тот же класс).\nИз этого следует в т.ч. то, что строго говоря бинарные отношения являются неупорядоченными (вырожденный случай), а также то, что зависимые отношения типа \"Между\" являются неупорядоченными.Warning\nЯ считаю, что описанный подход к [не]упорядоченности наверное не очень хорош - поскольку на данный момент нет возможности задать упорядоченное отношение, чьи объекты связи имеют один и тот же тип.\nВ будущем, данный механизм стоит переделать так, чтобы упорядоченность считалась поведением по умолчанию для всех отношений, вне зависимости от их типизации, а неупорядоченность нужно было отдельно указывать, и она была бы возможна только для связей, чьи объекты имеют один и тот же тип.\nОтношения, помимо своих основных параметров (имени и классов субъектов/объектов) имеют также дополнительные характеристики, которые могут повлиять на их смысловое значение, а также дополнительно ограничить особенности их применения.\nВсе это в коде задается сложным объектом RelationshipDef.kind, имеющим тип RelationshipKind.В основе этих дополнительных характеристик лежит разделение отношений на независимые (BaseRelationshipKind) и зависимые/вычисляемые (DependantRelationshipKind)\nНезависимые отношения являются состоянием отношений по-умолчанию. Независимые отношения определяют конкретные связи, которыми связаны конкретные объекты в модели предметной области. Связи именно этих отношений являются \"основой\" данных об отношениях в модели в принципе.\nЗависимые отношения, в отличие от независимых, не прописываются в модели напрямую, а вычисляются на основе других отношений. Они позволяют производить более сложные суждения о модели на основе существующих в ней связей по независимым отношениям.\nДанное разделение косвенно влияет на многие особенности отношений. Рассмотрим это ниже.\nУ любого бинарного отношения, будь оно зависимым или независимым, определяется количественность, называемая также квантификатором (класс LinkQuantifier, вычисляется в поле RelationshipDef.effectiveQuantifier) - это характеристика, определяющая максимальное возможное количество субъектов и объектов данной связи.Если говорить по-простому, то это характеристика \"один-ко-многим\", \"многие-ко-многим\" и т.п., знакомая нам из проектирования БД и подобного, только выраженная в количественном формате:\nПоле LinkQuantifier.subjCount указывает на то, сколько субъектов связи может существовать для одного заданного объекта связи.\nПоле LinkQuantifier.objCount указывает на то, сколько объектов связи может существовать для одного заданного субъекта связи.\nТак, если записать квантификатор в формате {subjCount -&gt; objCount}, то квантификатор {2 -&gt; 1} некоторого отношения A -&gt; rel(B) значит, что объекты класса А могут иметь только одну связь с объектом класса B, но с одним таким объектом класса B могут быть связаны 2 объекта класса А.\nПример использования квантификаторов (и нарушения ограничения, поставленного ими)//класс \"Питомец\"\nclass Pet //класс \"Человек\"\nclass Human { //Отношение \"имеет питомца\", связывает объекты \"Людей\" с объектами \"Питомцев\" //Имеет квантификатор \"один-ко-многим\" (здесь * означает неограниченность). //Т.е. у питомца может быть только один владелец, //но у владельца может быть неограниченное кол-во питомцев. rel hasPet(Pet) : {1 -&gt; *} ;\n} //Кот Бася, питомец\nobj basya : Pet\n//плюшевая альпака, питомец\nobj alpaca : Pet //Человек Юля\nobj yulia : Human { //Юля связана с Басей отношением \"имеет питомца\" hasPet(basya); //Юля также связана этим отношением c альпакой //- это не нарушает квантификатора, т.к. objCount отношения не ограничен hasPet(alpaca);\n} //Человек Марат\nobj marat : Human { //Данное утверждение о связи Марата с Басей отношением \"имеет питомца\" //нарушает квантификатор, поскольку subjCount данного отношения равен 1 hasPet(basya);\n}\nImportant\nЯвно задавать квантификаторы можно только для независимых отношений (поле BaseRelationshipKind.quantifier).\nПри этом, делать это не обязательно, т.к. при неуказании квантификатора отношение считается имеющим квантификатор по умолчанию: <br>Для отношений без <a data-tooltip-position=\"top\" aria-label=\"Шкала\" data-href=\"#Шкала\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Шкала_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">шкалы</a> - {* -&gt; *}, т.е. \"Многие ко многим\", что по сути значит отсутствие количественных ограничений\nДля отношений со шкалой - в соответствии со смыслом шкалы (см. ниже) Квантификаторы зависимых отношений вычисляются на основе квантификаторов отношений, от которых они зависят.\nНезависимые бинарные отношения могут задавать т.н. шкалу. Это опциональная характеристика, которая задает дополнительные ограничения на структуры, образованные объектами, связанными данным отношением.\nНа данный момент в системе поддерживается два вида шкал - линейная и частичная.Если отношение задает линейную шкалу, это значит, что все объекты, объединенные данным отношением, можно выстроить в линию, где каждый следующий объект указывает связью на предыдущий объект:<br>\n<img alt=\"relationship_linear_scale.png\" src=\"images/relationship_linear_scale.png\" target=\"_self\">\nПример использования отношения, задающего линейную шкалу://Слово в тексте\nclass Word { obj prop text : string ; //Отношение \"Идет после предыдущего слова\" задает линейную шкалу rel isAfter(Word) : Linear ;\n} obj word1 : Word { text = \"Мама\" ;\n} obj word2 : Word { text = \"мыла\" ; isAfter(word1) ;\n} obj word3 : Word { text = \"раму\" ; isAfter(word2) ;\n}\nИз данного определения вытекает, что класс-субъект и класс-объект данного отношения одинаковы - поскольку каждый объект в цепочке выступает как в качестве субъекта, так и в качестве объекта.\nТакже, исходя из данного определения, квантификатор отношения, задающего линейную шкалу, всегда равен \"один-к-одному\" ({ 1 -&gt; 1 }), т.к. единственный следующий объект может только ссылаться на единственный предыдущий, и наоборот.Если отношение задает частичную шкалу, это значит, что все объекты, объединенные данным отношением, можно выстроить в древовидную структуру, где каждый объект указывает связью на объект-родитель:<br>\n<img alt=\"relationship_partial_scale.png\" src=\"images/relationship_partial_scale.png\" target=\"_self\">\nПример использования отношения, задающего частичную шкалу://человек\nclass Person { //Отношение \"Является ребенком\" задает частичную шкалу rel isChildOf(Person) : Partial ;\n} obj mom : Person obj alice : Person { isChildOf(mom) ;\n} obj bob : Person { isChildOf(mom) ;\n}\nПо логике, аналогичной линейной шкале, класс-субъект отношения в частичной шкале так же равен классу-объекту.\nКвантификатор отношения, задающего частичную шкалу, не фиксирован полностью, но должен иметь значение objCount = 1 (т.е. { ... -&gt; 1 }), поскольку у субъекта-ребенка может быть только один объект-родитель. Квантификатором по умолчанию для него является { * -&gt; 1 }Warning\nНа данный момент отношения, задающие шкалы, проверяются на соответствие своим квантификаторам, что в принципе позволяет судить об их структуре, но есть нюанс - на данный момент не проверяется \"глобальность\" структур, образуемых данными отношениями.\nТ.е., по хорошему, линия или дерево, образуемые такими объектами, должны быть единственны во всей модели, и все объекты данного типа должны принадлежать одной структуре. Однако на данный момент система этого не проверяет - данное ограничение пока что остается на совести пользователя.\nПредоставляемая шкалами информация о том, какую структуру образовывают связанные отношением объекты, используется, в первую очередь, для возможности вычисления различных зависимых отношений на основе задаваемых независимых отношений, задающих шкалы. Об этом - в следующем разделе.Как было сказано выше, зависимые отношения по факту не существуют в данных модели (в модели не может быть соответствующего утверждения RelationshipLinkStatement), а вычисляются на основе других отношений.В таблице ниже представлены поддерживаемые типы зависимых отношений, требования для их объявления, и их смысл.\nДанные типы в коде задаются полем DependantRelationshipKind.type, имеющим тип DependantRelationshipKind.Type - это енам. В таблице, для краткости, связанные енам-константы будут писаться просто в виде Type.&lt;VALUE&gt;.\nВ данной таблице используются следующие обозначения:\nЗависимое отношение &lt;type&gt;Rel - конкретное отношение, рассматриваемое в строке таблицы (вместо &lt;type&gt; для понятности подставляется описание типа зависимости)\nОтношение-основа baseRel - отношение, от которого зависит depRel. Обратите внимание, что baseRel может быть как независимым, так и зависимым от какого-то другого отношения.\nКорневое отношение rootRel - последнее независимое отношение в цепочке зависимостей, начинающейся с depRel. Если baseRel независимое, то оно же и есть rootRel.\nTODOImportant\nСкорее всего, проекция не понадобится вам в работе с этим проектом. Это весьма странная и редко используемая фича, поэтому этот раздел вы скорее всего можете пропустить.\nТем не менее, для полноты информации фича описана.\nПроекцией, в контексте отношений, называется возможность подстановки объектов одного класса в утверждения о связи отношением для объектов другого класса.\nПроще всего это объяснить на примере. Рассмотрим следующую модель предметной области://Класс \"Игрушка\"\nclass Toy { //отношение \"имеет часть\" rel hasPart(ToyPart) : {1 -&gt; * };\n} //Класс \"Часть игрушки\"\nclass ToyPart { //отношение \"сделано из материала\" rel isMadeOf(Material) : {* -&gt; 1};\n} //Материал, из которого сделаны части игрушки\nclass Material //Кукла, игрушка\nobj doll : Toy { //Имеет часть - голову hasPart(dollHead); //Имеет часть - тело hasPart(dollBody);\n} //Голова куклы\nobj dollHead : ToyPart { //Сделана из пластика isMadeOf(plastic);\n} //Тело куклы\nobj dollBody : ToyPart { //Сделано из пластика isMadeOf(plastic);\n} obj plastic : Material\nВ подобной модели, в обычной ситуации, мы можем делать утверждение только об материале отдельных частей куклы. Но что, если мы хотим узнать, сделана ли сама кукла из пластика?\nВ теории, это можно проверить сложным образом, используя квантор общности (For All ...). Но подобная проверка весьма сложна в записи и понимании. В идеале, мы бы хотели проверить простое утверждение, записанное, например, так: doll =&gt; isMadeOf(plastic).\nТакое утверждение формально невалидно, но именно для этого существует проекция.Проекция класса A на класс A' возможна, когда в модели существует единственное отношение projRel (т.н. отношение проекции), удовлетворяющее следующим критериям:\nОно имеет типизацию A -&gt; projRel(A')\nОно имеет квантификатор, чей subjCount = 1 (т.е. {1 -&gt; ...})\nЕсли проекция класса A на класс A' возможна, то это значит, что объекты класса A могут использоваться в вычислимых утверждениях о связях по отношениям, в типизации которых указан класс A'.\nДля этого, каждому объекту a класса A ставится в соответствие множество объектов a'1 - a'N класса A', соединенных с ним отношением projRel. Утверждение о связи для объекта a верно, если оно верно для всех соответствующих объектов a'1 - a'N.Так, в приведенном примере, класс Toy может быть спроектирован на класс ToyPart, поскольку существует отношение проекции hasPart.\nТаким образом, объекту doll ставятся в соответствие объекты dollHead и dollBody, и утверждение doll =&gt; isMadeOf(plastic) \"раскрывается\" в dollHead =&gt; isMadeOf(plastic) И dollBody =&gt; isMadeOf(plastic).В общем случае, проекцией могут быть подставлены нескольку участников связи - в этом случае происходит комбинаторный перебор всех конфигураций соответствующих объектов.\nНапример, допустим есть некоторое отношение X -&gt; rel(Y, Z), и при этом существуют проекции A в Х, B в Y и C в Z.\nВ этой ситуации, допустим мы хотим проверить утверждение a =&gt; rel(b, c), где a проецируется в x1 и x2, b проецируется в y1 и y2, и c проецируется в z1 и z2\nВ таком случае, будут рассмотрены все конфигурации спроецированного утверждения:\nx1 =&gt; rel(y1, z1)\nx1 =&gt; rel(y1, z2)\nx1 =&gt; rel(y2, z1)\nx1 =&gt; rel(y2, z2)\nx2 =&gt; rel(y1, z1)\nx2 =&gt; rel(y1, z2)\nx2 =&gt; rel(y2, z1)\nx2 =&gt; rel(y2, z2)\nИ только если каждое из них выполняется, то выполняется исходное утверждение a =&gt; rel(b, c).Important\nУтверждения, возможные с помощью проекции, являются вычислимыми так же, как утверждения о зависимых отношениях. Это значит, что соответствующих утверждений (RelationshipLinkStatement) не может быть в самих данных.\nКласс-субъект отношения (RelationshipDef.subjectClassName) должен присутствовать в модели.Классы-объекты отношения (RelationshipDef.objectClassNames) должны присутствовать в модели.Для утверждения о связи объектов отношением, данное отношение должно присутствовать в модели.Для утверждения о связи объектов отношением, все объекты должны присутствовать в модели.Отношение, объявленное в конкретном классе, не может иметь имя, повторяющее имя одного из отношений, уже определенных в классе или его классах-родителях.Квантификатор могут задавать только бинарные независимые отношения.Шкалу могут задавать только бинарные независимые отношения.Если квантификатор задается отношением, которое задает шкалу, квантификатор должен соответствовать требованиям к данной шкале \"один-к-одному\" для линейной шкалы\n\"...-к-одному\" для частичной шкалы\nВ цепочке зависимости отношений не может быть рекурсии (отношение не может зависеть от самого себя).<br>Зависимые отношения должны удовлетворять <a data-tooltip-position=\"top\" aria-label=\"Типы зависимых отношений\" data-href=\"#Типы зависимых отношений\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типы_зависимых_отношений_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">требованиям</a> по типу зависимости.Утверждения о связи объектов отношением должны удовлетворять типизации отношения (по кол-ву объектов в связи и по их типу).Не может быть явно заданных утверждений о зависимых отношениях.Количество связей по отношениям у объектов должно удовлетворять квантификаторам этих отношений.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Основные моменты при работе с отношениями","level":2,"id":"Основные_моменты_при_работе_с_отношениями_0"},{"heading":"Типизация отношений","level":3,"id":"Типизация_отношений_0"},{"heading":"Направленность","level":3,"id":"Направленность_0"},{"heading":"\"Арность\"","level":3,"id":"\"Арность\"_0"},{"heading":"Упорядоченность","level":3,"id":"Упорядоченность_0"},{"heading":"Характеристики отношений","level":2,"id":"Характеристики_отношений_0"},{"heading":"Количественность (Квантификатор)","level":3,"id":"Количественность_(Квантификатор)_0"},{"heading":"Шкала","level":3,"id":"Шкала_0"},{"heading":"Типы зависимых отношений","level":3,"id":"Типы_зависимых_отношений_0"},{"heading":"Параметризация","level":2,"id":"Параметризация_0"},{"heading":"Проекция","level":2,"id":"Проекция_0"},{"heading":"Корректность данных (валидация)","level":2,"id":"Корректность_данных_(валидация)_0"},{"heading":"Полнота","level":3,"id":"Полнота_0"},{"heading":"Валидность","level":3,"id":"Валидность_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Шкала_0","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html#Типы_зависимых_отношений_0"],"author":"","coverImageURL":"images/relationship_demo.png","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","pathToRoot":"../..","attachments":["images/relationship_demo.png","images/relationship_arity.png","images/relationship_linear_scale.png","images/relationship_partial_scale.png"],"createdTime":1755797001912,"modifiedTime":1755895710161,"sourceSize":33992,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Отношения.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","showInTree":true,"treeOrder":13,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html":{"title":"Перечисления (Enum)","icon":"","description":"Перечисления - это задаваемые пользователем (автором предметной области) <a data-tooltip-position=\"top\" aria-label=\"Типы данных\" data-href=\"Типы данных\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">типы данных</a>, имеющих конечное (перечислимое) количество именованных значений. Они используются в первую очередь как настраиваемые типы данных для <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойств</a>.Пример перечисления и его использования://Перечисление \"Направление\"\nenum Direction { //Значения перечисления //Значение \"вверх\" UP, //Значение \"вниз\" DOWN, //Значение \"влево\" LEFT, //Значение \"вправо\" RIGHT\n} //Класс \"Указатель\"\nclass Pointer { //Свойство \"направление указателя\", имеющие тип перечисления \"Направление\" obj prop pointDirection : Direction;\n} //Объект класса \"Указатель\"\nobj myPointer : Pointer { //Свойство объекта принимает значение \"Направление:вверх\" pointDirection = Direction:UP ;\n}\n<br>Стоит отметить, что в отличие от, например, Java, перечисления в нашей модели не являются <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классами</a>, а значения перечисления - не являются <a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объектами</a>. Перечисления и их значения это отдельно задаваемый тип данных, не связанный с системой классов/объектов.В коде определения перечислений представлены классом EnumDef\nСостав базовой хранимой информации:\nИмя перечисления (EnumDef.name)\nЗначения перечисления (EnumDef.values)\n<br>Связанные с перечислением <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданные</a> (EnumDef.metadata)\nЗначения перечислений представлены классом EnumValueDef\nСостав базовой хранимой информации:\nИмя перечисления, которому значение принадлежит (EnumValueDef.enumName)\nИмя самого значения (EnumValueDef.name)\n<br>Связанные со значением <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданные</a> (EnumValueDef.metadata)\nДа особо ничего :) Они весьма простые, выше в принципе вся необходимая информация.\nЗа исключением...Перечисления являются единственным типом сущности в системе, для которых задаются так называемые \"встроенные значения\" - определения, которые всегда есть в любой модели.Вкратце о самом термине: в теории, возможность добавить встроенные значения присутствует для любого типа сущностей (см. DefContainer#addBuiltIn), но реализована она только для перечислений. Встроенные значения не считаются в общем количестве определений, и не выводятся в различных видах записи (например, LOQI), но присутствуют в соответствующих контейнерах, и могут быть получены методом get, по имени.Для перечислений такое значение одно: перечисление под названием Comparison, которое имеет значения Comparison:less, Comparison:greater и Comparison:equal. Как можно понять по названиям, данное перечисление представляет собой результат сравнения двух значений: первое значение может быть меньше/больше/равно второму соответственно.\nВстраивание данного типа нужно, чтобы в любой модели работал оператор сравнения, возвращающий значение данного перечисления.Особых проверок корректности нет. (Кроме очевидного, поддерживаемого на уровне кода: имена значений не должны повторяться внутри одного перечисления).","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Что нужно знать про перечисления","level":2,"id":"Что_нужно_знать_про_перечисления_0"},{"heading":"\"Встроенные\" перечисления","level":2,"id":"\"Встроенные\"_перечисления_0"},{"heading":"Корректность данных (валидация)","level":2,"id":"Корректность_данных_(валидация)_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","pathToRoot":"../..","attachments":[],"createdTime":1755797001912,"modifiedTime":1755895710166,"sourceSize":5135,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Перечисления (Enum).md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","showInTree":true,"treeOrder":14,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html":{"title":"Свойства","icon":"","description":"Свойства - это некоторые значения, хранящиеся в <a data-tooltip-position=\"top\" aria-label=\"Классы\" data-href=\"Классы\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">классах</a>/<a data-tooltip-position=\"top\" aria-label=\"Объекты\" data-href=\"Объекты\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">объектах</a>, и описывающие их.\nНабор свойств, имеющийся у конкретной сущности, задается в классах, от которых данная сущность наследуется.Пример использования свойствclass Cat { //свойство \"возраст\" целочисленного типа, // определенное для объектов класса \"кот\" obj prop age: int[0, 100] ;\n} obj Basya : Cat { //Конкретное значение свойства \"возраст\", присущее объекту \"Бася\" класса \"кот\" age = 2 ;\n}\nВ коде определения свойств представлены классом PropertyDef\nСостав базовой хранимой информации:\nИмя свойства (PropertyDef.name)\nИмя класса, объявившего свойство (PropertyDef.declaringClassName)\n<br><a data-tooltip-position=\"top\" aria-label=\"Типы значений свойств\" data-href=\"#Типы значений свойств\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Типы_значений_свойств_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Тип</a> значения свойства (PropertyDef.type)\n<br><a data-tooltip-position=\"top\" aria-label=\"Объектные и классовые свойства\" data-href=\"#Объектные и классовые свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные_и_классовые_свойства_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Вид</a> свойства (PropertyDef.kind)\n<br>Связанные со свойством <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданные</a> (PropertyDef.metadata)\nУтверждения о значении свойств представлены классом PropertyValueStatement\nСостав базовой хранимой информации:\nСущность, которой принадлежит значение - класс/объект (PropertyValueStatement.owner)\nИмя свойства (PropertyValueStatement.propertyName)\nЗадаваемое значение свойства (PropertyValueStatement.value)\nВ системе есть разграничения между объектными и классовыми свойствами. Как следует из названия, это различие определяет, какой сущности могут принадлежать свойства - классам или объектам.\nДля аналогии можно опять же вспомнить Java - классовые свойства похожи на static поля, т.к. принадлежат классам. Объектные же свойства аналогичны обычным полям, т.к. принадлежат отдельным объектам и разнятся от объекта к объектуСоответственно, значение свойства можно определять только в сущности, соответствующей виду данного свойстваПример использования различных видов свойств//класс \"Животное\"\nclass Animal { //свойство \"является разумным\" является классовым, // а то есть принадлежит классу и определяется в нем - // поскольку это свойство не может разниться // от одного животного к другому внутри одного класса class prop isSentient : bool = false ; //свойство \"возраст\" является объектным, // а то есть принадлежит объектам класса и определяется в них - // поскольку это свойство может разниться от одного животного к другому obj prop age: int[0, 100] ;\n} //класс \"Человек\", наследуется от \"Животного\"\nclass Human : Animal { //В отличие от static-полей в Java, классовые свойства в нашей системе // могут наследоваться и переопределяться в классах наследниках. //Так, \"Человек\" переопределяет для своих объектов свойство \"является разумным\" isSentient = true ;\n} //объект \"Петя\", инстанс класса \"Человек\"\nobj Petya : Human { //значение объектного свойства определяется в объекте age = 20 ;\n}\nЗначения свойств, вне зависимости от их вида и типа, наследуются и могут переопределяться - это можно видеть в примере выше.На практике это значит, что процесс получения значения свойства для текущей сущности происходит по следующему простому принципу:\nПока значение не найдено: Если текущая сущность определяет значение свойства, вернуть его\nИначе перейти к родительскому классу текущей сущности (Именно так реализован код в методе ClassInheritorDef.getPropertyValue())Из этого следует, что с помощью наследования в конкретном объекте можно получить значения свойств, определенных в самом этом объекте или в его родительских классах (т.к. они наследуются)\nПри этом, конечно, стоит учитывать ограничения, описанные в предыдущем разделе - так, значение объектного свойства можно найти только в самом объекте, а вот значение классового свойства можно быть получено только из его родительских классов.<br>Любое свойство обязано указывать <a data-tooltip-position=\"top\" aria-label=\"Типы данных\" data-href=\"Типы данных\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">тип своего значения</a> (поле PropertyDef.type).\nСвойства могут иметь следующие типы:\nБулево значение, BooleanType\nЦелые числа, IntegerType\nДробные числа, DoubleType\nСтроки, StringType\nПеречисления EnumType\n<br>Это обусловлено тем, что только данные типы считаются в системе \"примитивными\", поскольку они не взаимодействуют с объектной стороной системы (в отличие от типов ClassType и ObjectType) - возможность \"запихнуть\" в значение свойства объект или класс нарушала бы принципы системы. Для подобного связывания между объектами есть <a data-tooltip-position=\"top\" aria-label=\"Отношения\" data-href=\"Отношения\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">отношения</a>.TODOКласс, объявляющий свойство (PropertyDef.declaringClassName), должен присутствовать в модели.В случае, если свойство имеет перечислимый тип (enum), то заданное перечисление должно присутствовать в модели.Для утверждения о значении свойства, данное свойство должно присутствовать в модели.Свойство, объявленное в конкретном классе, не может иметь имя, повторяющее имя одного из свойств, уже определенных в классе или его классах-родителях.Значения классовых свойств должны быть определены только в классах, а объектных - в объектах.Тип значения свойства должен соответствовать объявленному типу свойства.В случае, если класс является конкретным (в модели существуют объекты, являющиеся прямыми инстансами этого класса), то в нем должны быть определены значения для всех классовых свойств, указанных в нем и его родительских классах (с учетом наследования их значений).\nТ.е. не допускается ситуация, когда какой-то объект наследуется от класса, но при этом в цепочке наследования для этого объекта не определено какое-то из свойств класса.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Объектные и классовые свойства","level":2,"id":"Объектные_и_классовые_свойства_0"},{"heading":"Получение значений свойств","level":2,"id":"Получение_значений_свойств_0"},{"heading":"Типы значений свойств","level":2,"id":"Типы_значений_свойств_0"},{"heading":"Параметризация","level":2,"id":"Параметризация_0"},{"heading":"Корректность данных (валидация)","level":2,"id":"Корректность_данных_(валидация)_0"},{"heading":"Полнота","level":3,"id":"Полнота_0"},{"heading":"Валидность","level":3,"id":"Валидность_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Типы_значений_свойств_0","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html#Объектные_и_классовые_свойства_0","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001914,"modifiedTime":1755895710180,"sourceSize":9450,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Свойства.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","showInTree":true,"treeOrder":15,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown"},"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html":{"title":"Типы данных","icon":"","description":"В системе присутствует различный функционал, связанный с различного рода управлением внутренними для модели данными (например, хранение значений <a data-tooltip-position=\"top\" aria-label=\"Свойства\" data-href=\"Свойства\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">свойств</a> и <a data-tooltip-position=\"top\" aria-label=\"Метаданные\" data-href=\"Метаданные\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">метаданных</a>, а также вычисление выражений в дереве решений).\nЧтобы система могла четко понимать характер данных, с которыми она работает, в ней реализован механизм типов данных.Типы данных в системе по смыслу и назначению аналогичны типам данных, существующих во всех строго типизированных языках программирования (той же Java).В коде классы, связанные с типизацией данных, расположены в пакете its.model.definition.types.\nОсновные классы, представляющие отдельные типы данных, являются наследниками класса Type, и предоставляют следующий функционал:\nметод fits(value) - можно ли привести значение value к данному типу\nметод castFits(subType) - можно ли привести тип subType к данному типу\nметод Type.of(value) - вернуть тип переданного значения.\nВ таблице ниже представлен список типов данных, поддерживаемых в системе на данный момент.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","pathToRoot":"../..","attachments":[],"createdTime":1755797001915,"modifiedTime":1755895710185,"sourceSize":8054,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Типы данных.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","showInTree":true,"treeOrder":16,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html"],"type":"markdown"},"1.-модели-(its_domainmodel)/об-its_domainmodel.html":{"title":"Об its_DomainModel","icon":"","description":"itsDomainModel - компонент, служащий основой для остальных компонентов Compprehensive ITS (its*), и отвечающий за создание и хранение необходимых моделей данных о предметной области.Здесь и ниже в этом разделе - различные обособленные примеры использования данного проекта. Описаны на Java, т.к. я думаю, что вы с большей вероятностью будете использовать именно ее (использование на Kotlin в принципе аналогично, и более просто)Создать <a data-tooltip-position=\"top\" aria-label=\"Модель предметной области\" data-href=\"Модель предметной области\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">модель предметной области</a> из <a data-tooltip-position=\"top\" aria-label=\"LOQI\" data-href=\"LOQI\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">.loqi</a> файла:DomainModel domainModel = DomainLoqiBuilder.buildDomain(new FileReader(filename)); <br>Создать модель предметной области из папки с <a data-tooltip-position=\"top\" aria-label=\"Словари + RDF\" data-href=\"Словари + RDF\" href=\"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">.csv словарями и RDF файлами</a>:DomainModel domainModel = DomainDictionariesRDFBuilder.buildDomain( directoryPath, Collections.emptySet() );\nНаполнить существующую модель данными из .loqi файла:domainModel.addMerge(DomainLoqiBuilder.buildDomain(new FileReader(newFilename)))\nНаполнить существующую модель данными из RDF:DomainRDFFiller.fillDomain( domainModel, ttlFilePath, //путь к .ttl файлу с RDF Collections.emptySet(), //или Set.of(DomainRDFFiller.Option.NARY_RELATIONSHIPS_OLD_COMPAT) someTtlBasePrefix //префикс, использующийся в .ttl файле - например RDFUtils.POAS_PREF );\nЗапись в виде LOQI:DomainLoqiWriter.saveDomain( domainModel, new FileWriter(filename), Collections.emptySet() );\nЗапись в виде RDF:DomainRDFWriter.saveDomain( domainModel, new FileWriter(filename), someTtlBasePrefix, //префикс, использующийся в .ttl файле - например RDFUtils.POAS_PREF Collections.emptySet() //или Set.of(DomainRDFWriter.Option.NARY_RELATIONSHIPS_OLD_COMPAT) );\n<br>Построение <a data-tooltip-position=\"top\" aria-label=\"Дерево (граф) решений\" data-href=\"Дерево (граф) решений\" href=\"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">дерева решений</a> из .xml файлаDecisionTree decisionTree = DecisionTreeXMLBuilder.fromXMLFile(filename);\n//Строим и валидируем составную модель (предметная область + теги + деревья решений) DomainSolvingModel domainSolvingModel = new DomainSolvingModel( directoryPath, DomainSolvingModel.BuildMethod.LOQI ); domainSolvingModel.validate(); //Получаем общую модель для под-области DomainModel subDomainModel = domainSolvingModel.getMergedTagDomain(someTagName); //Получаем модель для конкретной ситуации DomainModel situationDomain = DomainLoqiBuilder.buildDomain(new FileReader(situationFileName)); //Объединяем модель ситуации с моделью под-области - делаем ее полной situationDomain.addMerge(subDomainModel); //Валидируем модель ситуации situationDomain.validateAndThrow(); //Получаем дерево решений из составной модели DecisionTree decisionTree = domainSolvingModel.getDecisionTree(); //...проводим дальнейшие вычисления (см. its_Reasoner)\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"С чего начать","level":2,"id":"С_чего_начать_0"},{"heading":"Создание модели предметной области","level":4,"id":"Создание_модели_предметной_области_0"},{"heading":"Дополнение модели предметной области новыми данными","level":4,"id":"Дополнение_модели_предметной_области_новыми_данными_0"},{"heading":"Запись модели предметной области в файл","level":4,"id":"Запись_модели_предметной_области_в_файл_0"},{"heading":"Создание дерева решений","level":4,"id":"Создание_дерева_решений_0"},{"heading":"Типичный пример использования моделей","level":3,"id":"Типичный_пример_использования_моделей_0"}],"links":["1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html"],"author":"","coverImageURL":"","fullURL":"1.-модели-(its_domainmodel)/об-its_domainmodel.html","pathToRoot":"..","attachments":[],"createdTime":1756108678955,"modifiedTime":1756110857102,"sourceSize":4209,"sourcePath":"1. Модели (its_DomainModel)/Об its_DomainModel.md","exportPath":"1.-модели-(its_domainmodel)/об-its_domainmodel.html","showInTree":true,"treeOrder":17,"backlinks":[],"type":"markdown"},"2.-вычисления-(its_reasoner)/об-its_reasoner.html":{"title":"Об its_Reasoner","icon":"","description":"its_Reasoner - компонент системы, служащий для реализации вычислений по графам мыслительных процессов, как это описано в статьях <a data-href=\"Дерево (граф) решений\" href=\"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Дерево (граф) решений</a>, <a data-href=\"Узлы\" href=\"1.-модели-(its_domainmodel)/дерево-решений/узлы.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Узлы</a>, <a data-href=\"Выражения\" href=\"1.-модели-(its_domainmodel)/дерево-решений/выражения.html\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">Выражения</a>.WIP\nЭта статья является \"скелетом\" и еще не дописана.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"С чего начать","level":2,"id":"С_чего_начать_0"}],"links":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html"],"author":"","coverImageURL":"","fullURL":"2.-вычисления-(its_reasoner)/об-its_reasoner.html","pathToRoot":"..","attachments":[],"createdTime":1756110791085,"modifiedTime":1756111204761,"sourceSize":445,"sourcePath":"2. Вычисления (its_Reasoner)/Об its_Reasoner.md","exportPath":"2.-вычисления-(its_reasoner)/об-its_reasoner.html","showInTree":true,"treeOrder":19,"backlinks":[],"type":"markdown"},"3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html":{"title":"Об its_QuestionGen","icon":"","description":"its_Reasoner - компонент системы, служащий для построения структуры наводящих вопросов на основе деревьев решений, а также для реализации текстового взаимодействия с пользователем на основе этой структурыWIP\nЭта статья является \"скелетом\" и еще не дописана.\n","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"С чего начать","level":2,"id":"С_чего_начать_0"}],"links":[],"author":"","coverImageURL":"","fullURL":"3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html","pathToRoot":"..","attachments":[],"createdTime":1756111159512,"modifiedTime":1756111234776,"sourceSize":506,"sourcePath":"3. Наводящие вопросы (its_QuestionGen)/Об its_QuestionGen.md","exportPath":"3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html","showInTree":true,"treeOrder":21,"backlinks":[],"type":"markdown"},"index.html":{"title":"index","icon":"","description":"Данная вики описывает функционал и код проекта под общим названием Compprehensive ITS, созданных для организации автоматизированного обучения с помощью моделей мышления учащихся.Проекты Compprehensive ITS включают в себя несколько компонентов:\n<a data-tooltip-position=\"top\" aria-label=\"https://github.com/Max-Person/its_DomainModel\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Max-Person/its_DomainModel\" target=\"_self\">its_DomainModel</a> - создание, валидация и преобразование моделей данных (модели данных о конкретных задачах, а также модели деревьев решений, решающих эти задачи).\n<br><a data-tooltip-position=\"top\" aria-label=\"https://github.com/Max-Person/its_Reasoner\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Max-Person/its_Reasoner\" target=\"_self\">its_Reasoner</a> - вычисления (reasoning) на основе деревьев решений.\n<br><a data-tooltip-position=\"top\" aria-label=\"https://github.com/Max-Person/its_QuestionGen\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Max-Person/its_QuestionGen\" target=\"_self\">its_QuestionGen</a> - создание наводящих вопросов на основе деревьев решений, текстовое взаимодействие с пользователем.\n<br>Данные компоненты задуманы для использования в качестве библиотек в других проектах, написанных на Java или Kotlin (подробнее про языки <a data-tooltip-position=\"top\" aria-label=\"Java и Kotlin\" data-href=\"#Java и Kotlin\" href=\"index.html#Java_и_Kotlin_0\" class=\"internal-link\" target=\"_self\" rel=\"noopener nofollow\">ниже</a>), т.е. сами не несут исполняемого кода как такового.\nПодробнее о функционале, предоставляемым данными библиотеками, читайте в остальных частях вики (содержание можно видеть слева).Ниже - о том, как начать использовать данный проект.<br>Как автор данных проектов, я рекомендую использовать Maven + <a data-tooltip-position=\"top\" aria-label=\"https://jitpack.io/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://jitpack.io/\" target=\"_self\">JitPack</a> для подключения проектов its_* как зависимостей в ваших собственных проектах.\nДля этого необходимо:\n1. В pom.xml своего проекта указать репозиторий JitPack:&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;jitpack.io&lt;/id&gt; &lt;url&gt;https://jitpack.io&lt;/url&gt; &lt;/repository&gt;\n&lt;/repositories&gt;\n2. Также в pom.xml указать необходимые компоненты как зависимости:&lt;dependency&gt; &lt;groupId&gt;com.github.Max-Person&lt;/groupId&gt; &lt;artifactId&gt;its_DomainModel&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt; &lt;groupId&gt;com.github.Max-Person&lt;/groupId&gt; &lt;artifactId&gt;its_Reasoner&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt; &lt;groupId&gt;com.github.Max-Person&lt;/groupId&gt; &lt;artifactId&gt;its_QuestionGen&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt;\n&lt;/dependency&gt; В качестве версии JitPack может принимать название ветки, тег (release tag), или хэш коммита. Для данных проектов я рекомендую указывать либо master-SNAPSHOT для получения самых последних изменений с master-ветки, либо хэш конкретного коммита (например самого нового), чтобы ваш проект не сломался с обновлением библиотек.\nВ зависимости от ваших нужд, вам могут понадобиться не все из этих зависимостей.\n(например, its_QuestionGen может быть не нужен, если вы не взаимодействуете с системой задавания наводящих вопросов)\nits_Reasoner зависит от its_DomainModel, а its_QuestionGen зависит от них обоих. В связи с этим, вы можете указать только \"наиболее дочернюю\" зависимость, чтобы подтянуть и родительские тоже.\n(например, указать только its_Reasoner, чтобы подтянуть its_DomainModel) Однако если вы укажете все необходимые зависимости, это поможет вам более точно контролировать их версии.. 3. В IntelliJ IDEA надо обновить зависимости Maven (Maven -&gt; Reload All Maven Projects), и все, данный проект настроен для использования в качестве библиотеки.Note\nОбратите внимание, что JitPack собирает нужные артефакты только по запросу - т.е. когда вы подтягиваете зависимость. Это значит, что первое подобное подтягивание скорее всего займет несколько минут - JitPack-у нужно будет время на билд.\nПосле завершения такого долгого билда, в IDEA может отобразиться надпись \"Couldn't aqcuire locks\", как будто произошла ошибка - в этом случае просто обновитесь еще раз, это будет быстро.\n4. Вместе с артефактами данной библиотеки всегда доступен ее исходный код, а в нем и документация (kotlindoc/javadoc). Проект на 90% задокументирован, поэтому смотрите на документацию к используемым вами методам!\nДля того, чтобы исходный код и документация тоже подтянулись, нужно в IntelliJ IDEA сделать Maven -&gt; Download Sources and/or Documentation -&gt; Download Sources and DocumentationJitPack позволяет использовать GitHub-репозитории в качестве Maven-артефактов, а т.е. позволяет подтягивать Maven-зависимости прямо из репозиториев. Это кажется самым простым способом использовать данный проект.Тем не менее, если вы хотите иметь больше контроля над проектом (например если вы сошли с ума хотите поменять в нем какую-то логику), вы можете собрать его самостоятельно:\nСклонируйте необходимый репозиторий (или репозитории)\nЗапустите установку mvn install\n(в IntelliJ IDEA: Maven -&gt; Имя проекта -&gt; Lifecycle -&gt; install)\nПосле установки проект появится как артефакт (соответствующий указанным в pom.xml данным) в вашем локальном Maven-репозитории (.m2)\nУкажите в вашем проекте соответствующую зависимость.\nЗдесь вкратце о том, почему здесь все написано на Kotlin, и что с этим делать.Kotlin выбран для проекта без особых на то причин - когда он только начинался, мы посчитали что это будет хорошей возможностью познакомиться с новым языком. В принципе, об этом решении мы не пожалели - это оказался действительно интересный и приятный язык.<br>При этом, Kotlin компилируется под JVM, а значит, <a data-tooltip-position=\"top\" aria-label=\"https://kotlinlang.org/docs/java-to-kotlin-interop.html\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://kotlinlang.org/docs/java-to-kotlin-interop.html\" target=\"_self\">может быть вызван из Java-кода</a>. Это значит, что использование данных библиотек возможно из ваших Java-проектов, если вам комфортнее использовать знакомую джаву, чем неизвестный котлин (что, в принципе, понимаемо).\nПри подобном использовании могут возникать некоторые заминки и различия (например в том, как называются параметры методов, и как они передаются), но существенных проблем в таком подходе нет.<br>Эта вики создана и редактируется в отдельном репозитории <a data-tooltip-position=\"top\" aria-label=\"https://github.com/Max-Person/Compprehensive_ITS_wiki\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/Max-Person/Compprehensive_ITS_wiki\" target=\"_self\">Compprehensive_ITS_wiki</a>, представляющем отдельное <a data-tooltip-position=\"top\" aria-label=\"https://obsidian.md/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://obsidian.md/\" target=\"_self\">Obsidian</a>-хранилище Markdown файлов.<br>\nДанные файлы экспортируются в виде html-страниц с помощью плагина <a data-tooltip-position=\"top\" aria-label=\"https://github.com/KosmosisDire/obsidian-webpage-export\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://github.com/KosmosisDire/obsidian-webpage-export\" target=\"_self\">Obsidian Webpage Export</a>, и хостятся с помощью <a data-tooltip-position=\"top\" aria-label=\"https://pages.github.com/\" rel=\"noopener nofollow\" class=\"external-link is-unresolved\" href=\"https://pages.github.com/\" target=\"_self\">GitHub Pages</a>.Ранее вы могли видеть более старую версию этой вики в разделе Wiki репозитория its_DomainModel, однако я решил вынести ее как более централизованный справочник после того, как узнал о такой возможности.","aliases":[],"inlineTags":[],"frontmatterTags":[],"headers":[{"heading":"Установка зависимостей","level":2,"id":"Установка_зависимостей_0"},{"heading":"Альтернативные варианты установки","level":3,"id":"Альтернативные_варианты_установки_0"},{"heading":"Java и Kotlin","level":2,"id":"Java_и_Kotlin_0"},{"heading":"Об этой вики","level":2,"id":"Об_этой_вики_0"}],"links":["index.html#Java_и_Kotlin_0"],"author":"","coverImageURL":"","fullURL":"index.html","pathToRoot":".","attachments":[],"createdTime":1755795195793,"modifiedTime":1756110544617,"sourceSize":9919,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":22,"backlinks":["index.html"],"type":"markdown"}},"fileInfo":{"1.-модели-(its_domainmodel)/дерево-решений/выражения.html":{"createdTime":1755797001906,"modifiedTime":1755895710101,"sourceSize":54669,"sourcePath":"1. Модели (its_DomainModel)/Дерево решений/Выражения.md","exportPath":"1.-модели-(its_domainmodel)/дерево-решений/выражения.html","showInTree":true,"treeOrder":2,"backlinks":["2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html":{"createdTime":1755797001907,"modifiedTime":1755895710104,"sourceSize":17827,"sourcePath":"1. Модели (its_DomainModel)/Дерево решений/Дерево (граф) решений.md","exportPath":"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","showInTree":true,"treeOrder":3,"backlinks":["2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/дерево-решений/узлы.html":{"createdTime":1755797001907,"modifiedTime":1755895710120,"sourceSize":40385,"sourcePath":"1. Модели (its_DomainModel)/Дерево решений/Узлы.md","exportPath":"1.-модели-(its_domainmodel)/дерево-решений/узлы.html","showInTree":true,"treeOrder":4,"backlinks":["2.-вычисления-(its_reasoner)/об-its_reasoner.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/дерево-решений/узлы.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html":{"createdTime":1755797001914,"modifiedTime":1756111246319,"sourceSize":109,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Представления данных/Словари + RDF.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","showInTree":true,"treeOrder":7,"backlinks":["1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html":{"createdTime":1755797001914,"modifiedTime":1755895710170,"sourceSize":31856,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Представления данных/LOQI.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","showInTree":true,"treeOrder":8,"backlinks":["1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html":{"createdTime":1755797001909,"modifiedTime":1755895710130,"sourceSize":4318,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Классы.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","showInTree":true,"treeOrder":9,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html":{"createdTime":1755797001910,"modifiedTime":1755895710143,"sourceSize":5549,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Метаданные.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","showInTree":true,"treeOrder":10,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html":{"createdTime":1755797001910,"modifiedTime":1755895710155,"sourceSize":15233,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Модель предметной области.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","showInTree":true,"treeOrder":11,"backlinks":["1.-модели-(its_domainmodel)/об-its_domainmodel.html","1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html":{"createdTime":1755797001911,"modifiedTime":1755895710158,"sourceSize":4680,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Объекты.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","showInTree":true,"treeOrder":12,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html":{"createdTime":1755797001912,"modifiedTime":1755895710161,"sourceSize":33992,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Отношения.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","showInTree":true,"treeOrder":13,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html":{"createdTime":1755797001912,"modifiedTime":1755895710166,"sourceSize":5135,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Перечисления (Enum).md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","showInTree":true,"treeOrder":14,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html":{"createdTime":1755797001914,"modifiedTime":1755895710180,"sourceSize":9450,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Свойства.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","showInTree":true,"treeOrder":15,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html":{"createdTime":1755797001915,"modifiedTime":1755895710185,"sourceSize":8054,"sourcePath":"1. Модели (its_DomainModel)/Модель предметной области/Типы данных.md","exportPath":"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","showInTree":true,"treeOrder":16,"backlinks":["1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html"],"type":"markdown","data":null},"1.-модели-(its_domainmodel)/об-its_domainmodel.html":{"createdTime":1756108678955,"modifiedTime":1756110857102,"sourceSize":4209,"sourcePath":"1. Модели (its_DomainModel)/Об its_DomainModel.md","exportPath":"1.-модели-(its_domainmodel)/об-its_domainmodel.html","showInTree":true,"treeOrder":17,"backlinks":[],"type":"markdown","data":null},"2.-вычисления-(its_reasoner)/об-its_reasoner.html":{"createdTime":1756110791085,"modifiedTime":1756111204761,"sourceSize":445,"sourcePath":"2. Вычисления (its_Reasoner)/Об its_Reasoner.md","exportPath":"2.-вычисления-(its_reasoner)/об-its_reasoner.html","showInTree":true,"treeOrder":19,"backlinks":[],"type":"markdown","data":null},"3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html":{"createdTime":1756111159512,"modifiedTime":1756111234776,"sourceSize":506,"sourcePath":"3. Наводящие вопросы (its_QuestionGen)/Об its_QuestionGen.md","exportPath":"3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html","showInTree":true,"treeOrder":21,"backlinks":[],"type":"markdown","data":null},"index.html":{"createdTime":1755795195793,"modifiedTime":1756110544617,"sourceSize":9919,"sourcePath":"index.md","exportPath":"index.html","showInTree":true,"treeOrder":22,"backlinks":["index.html"],"type":"markdown","data":null},"site-lib/fonts/94f2f163d4b698242fef.otf":{"createdTime":1756112832858,"modifiedTime":1756112832858,"sourceSize":66800,"sourcePath":"","exportPath":"site-lib/fonts/94f2f163d4b698242fef.otf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/72505e6a122c6acd5471.woff2":{"createdTime":1756112832859,"modifiedTime":1756112832859,"sourceSize":104232,"sourcePath":"","exportPath":"site-lib/fonts/72505e6a122c6acd5471.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/2d5198822ab091ce4305.woff2":{"createdTime":1756112832861,"modifiedTime":1756112832861,"sourceSize":104332,"sourcePath":"","exportPath":"site-lib/fonts/2d5198822ab091ce4305.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/c8ba52b05a9ef10f4758.woff2":{"createdTime":1756112832863,"modifiedTime":1756112832863,"sourceSize":98868,"sourcePath":"","exportPath":"site-lib/fonts/c8ba52b05a9ef10f4758.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cb10ffd7684cd9836a05.woff2":{"createdTime":1756112832864,"modifiedTime":1756112832864,"sourceSize":106876,"sourcePath":"","exportPath":"site-lib/fonts/cb10ffd7684cd9836a05.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/293fd13dbca5a3e450ef.woff2":{"createdTime":1756112832865,"modifiedTime":1756112832865,"sourceSize":105924,"sourcePath":"","exportPath":"site-lib/fonts/293fd13dbca5a3e450ef.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/085cb93e613ba3d40d2b.woff2":{"createdTime":1756112832867,"modifiedTime":1756112832867,"sourceSize":112184,"sourcePath":"","exportPath":"site-lib/fonts/085cb93e613ba3d40d2b.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/b5f0f109bc88052d4000.woff2":{"createdTime":1756112832871,"modifiedTime":1756112832871,"sourceSize":105804,"sourcePath":"","exportPath":"site-lib/fonts/b5f0f109bc88052d4000.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/cbe0ae49c52c920fd563.woff2":{"createdTime":1756112832871,"modifiedTime":1756112832871,"sourceSize":106108,"sourcePath":"","exportPath":"site-lib/fonts/cbe0ae49c52c920fd563.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/535a6cf662596b3bd6a6.woff2":{"createdTime":1756112832872,"modifiedTime":1756112832872,"sourceSize":111708,"sourcePath":"","exportPath":"site-lib/fonts/535a6cf662596b3bd6a6.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/70cc7ff27245e82ad414.ttf":{"createdTime":1756112832886,"modifiedTime":1756112832886,"sourceSize":192740,"sourcePath":"","exportPath":"site-lib/fonts/70cc7ff27245e82ad414.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/454577c22304619db035.ttf":{"createdTime":1756112832873,"modifiedTime":1756112832873,"sourceSize":161376,"sourcePath":"","exportPath":"site-lib/fonts/454577c22304619db035.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/52ac8f3034507f1d9e53.ttf":{"createdTime":1756112832888,"modifiedTime":1756112832888,"sourceSize":191568,"sourcePath":"","exportPath":"site-lib/fonts/52ac8f3034507f1d9e53.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/05b618077343fbbd92b7.ttf":{"createdTime":1756112832876,"modifiedTime":1756112832876,"sourceSize":155288,"sourcePath":"","exportPath":"site-lib/fonts/05b618077343fbbd92b7.ttf","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2":{"createdTime":1756112832852,"modifiedTime":1756112832852,"sourceSize":7876,"sourcePath":"","exportPath":"site-lib/fonts/4bb6ac751d1c5478ff3a.woff2","showInTree":false,"treeOrder":0,"backlinks":[],"type":"font","data":null},"site-lib/media/6155340132a851f6089e.svg":{"createdTime":1756112832852,"modifiedTime":1756112832852,"sourceSize":315,"sourcePath":"","exportPath":"site-lib/media/6155340132a851f6089e.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/media/2308ab1944a6bfa5c5b8.svg":{"createdTime":1756112832855,"modifiedTime":1756112832855,"sourceSize":278,"sourcePath":"","exportPath":"site-lib/media/2308ab1944a6bfa5c5b8.svg","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/html/file-tree-content.html":{"createdTime":1756112833235,"modifiedTime":1756112833235,"sourceSize":11585,"sourcePath":"","exportPath":"site-lib/html/file-tree-content.html","showInTree":false,"treeOrder":0,"backlinks":[],"type":"html","data":null},"site-lib/scripts/webpage.js":{"createdTime":1756112621222,"modifiedTime":1756112621222,"sourceSize":110729,"sourcePath":"","exportPath":"site-lib/scripts/webpage.js","showInTree":false,"treeOrder":0,"backlinks":[],"type":"script","data":null},"site-lib/media/favicon.png":{"createdTime":1756112832724,"modifiedTime":1756112832724,"sourceSize":1105,"sourcePath":"","exportPath":"site-lib/media/favicon.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/styles/obsidian.css":{"createdTime":1756112833032,"modifiedTime":1756112833032,"sourceSize":198316,"sourcePath":"","exportPath":"site-lib/styles/obsidian.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/global-variable-styles.css":{"createdTime":1756112832882,"modifiedTime":1756112832882,"sourceSize":305,"sourcePath":"","exportPath":"site-lib/styles/global-variable-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"site-lib/styles/main-styles.css":{"createdTime":1756112621259,"modifiedTime":1756112621259,"sourceSize":19521,"sourcePath":"","exportPath":"site-lib/styles/main-styles.css","showInTree":false,"treeOrder":0,"backlinks":[],"type":"style","data":null},"images/relationship_demo.png":{"createdTime":1728816911123,"modifiedTime":1728817100572,"sourceSize":13079,"sourcePath":"images/relationship_demo.png","exportPath":"images/relationship_demo.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/relationship_arity.png":{"createdTime":1728816911124,"modifiedTime":1728817100571,"sourceSize":34102,"sourcePath":"images/relationship_arity.png","exportPath":"images/relationship_arity.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/relationship_linear_scale.png":{"createdTime":1728816911125,"modifiedTime":1728817100573,"sourceSize":16216,"sourcePath":"images/relationship_linear_scale.png","exportPath":"images/relationship_linear_scale.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/relationship_partial_scale.png":{"createdTime":1728816911115,"modifiedTime":1728817100574,"sourceSize":44434,"sourcePath":"images/relationship_partial_scale.png","exportPath":"images/relationship_partial_scale.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_branchresultnode.png":{"createdTime":1739611959307,"modifiedTime":1740655867035,"sourceSize":67474,"sourcePath":"images/nodes_BranchResultNode.png","exportPath":"images/nodes_branchresultnode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_questionnode.png":{"createdTime":1740649197067,"modifiedTime":1740655867038,"sourceSize":41907,"sourcePath":"images/nodes_QuestionNode.png","exportPath":"images/nodes_questionnode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_tuplequestionnode.png":{"createdTime":1740649179967,"modifiedTime":1740655867040,"sourceSize":99415,"sourcePath":"images/nodes_TupleQuestionNode.png","exportPath":"images/nodes_tuplequestionnode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_findactionnode.png":{"createdTime":1740649210004,"modifiedTime":1740655867037,"sourceSize":55209,"sourcePath":"images/nodes_FindActionNode.png","exportPath":"images/nodes_findactionnode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_sim_and.png":{"createdTime":1740647038147,"modifiedTime":1740655867046,"sourceSize":49773,"sourcePath":"images/nodes_sim_and.png","exportPath":"images/nodes_sim_and.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_sim_or.png":{"createdTime":1740647052762,"modifiedTime":1740655867047,"sourceSize":70361,"sourcePath":"images/nodes_sim_or.png","exportPath":"images/nodes_sim_or.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_mutex.png":{"createdTime":1740647117291,"modifiedTime":1740655867045,"sourceSize":49519,"sourcePath":"images/nodes_mutex.png","exportPath":"images/nodes_mutex.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_hyp.png":{"createdTime":1740647168858,"modifiedTime":1740655867044,"sourceSize":68710,"sourcePath":"images/nodes_hyp.png","exportPath":"images/nodes_hyp.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_seq.png":{"createdTime":1740647192637,"modifiedTime":1740656282858,"sourceSize":53710,"sourcePath":"images/nodes_seq.png","exportPath":"images/nodes_seq.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_branchaggregationnode.png":{"createdTime":1740649231620,"modifiedTime":1740655867034,"sourceSize":64056,"sourcePath":"images/nodes_BranchAggregationNode.png","exportPath":"images/nodes_branchaggregationnode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_cycleaggregationnode.png":{"createdTime":1740649244405,"modifiedTime":1740655867036,"sourceSize":83520,"sourcePath":"images/nodes_CycleAggregationNode.png","exportPath":"images/nodes_cycleaggregationnode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/nodes_whilecyclenode.png":{"createdTime":1740655486921,"modifiedTime":1740655867043,"sourceSize":118000,"sourcePath":"images/nodes_WhileCycleNode.png","exportPath":"images/nodes_whilecyclenode.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"images/decision_tree_sample.png":{"createdTime":1737305889673,"modifiedTime":1737356405998,"sourceSize":114493,"sourcePath":"images/decision_tree_sample.png","exportPath":"images/decision_tree_sample.png","showInTree":false,"treeOrder":0,"backlinks":[],"type":"media","data":null},"site-lib/rss.xml":{"createdTime":1756112839547,"modifiedTime":1756112839547,"sourceSize":172129,"sourcePath":"","exportPath":"site-lib/rss.xml","showInTree":false,"treeOrder":0,"backlinks":[],"type":"other","data":null}},"sourceToTarget":{"1. Модели (its_DomainModel)/Дерево решений/Выражения.md":"1.-модели-(its_domainmodel)/дерево-решений/выражения.html","1. Модели (its_DomainModel)/Дерево решений/Дерево (граф) решений.md":"1.-модели-(its_domainmodel)/дерево-решений/дерево-(граф)-решений.html","1. Модели (its_DomainModel)/Дерево решений/Узлы.md":"1.-модели-(its_domainmodel)/дерево-решений/узлы.html","1. Модели (its_DomainModel)/Модель предметной области/Представления данных/Словари + RDF.md":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/словари-+-rdf.html","1. Модели (its_DomainModel)/Модель предметной области/Представления данных/LOQI.md":"1.-модели-(its_domainmodel)/модель-предметной-области/представления-данных/loqi.html","1. Модели (its_DomainModel)/Модель предметной области/Классы.md":"1.-модели-(its_domainmodel)/модель-предметной-области/классы.html","1. Модели (its_DomainModel)/Модель предметной области/Метаданные.md":"1.-модели-(its_domainmodel)/модель-предметной-области/метаданные.html","1. Модели (its_DomainModel)/Модель предметной области/Модель предметной области.md":"1.-модели-(its_domainmodel)/модель-предметной-области/модель-предметной-области.html","1. Модели (its_DomainModel)/Модель предметной области/Объекты.md":"1.-модели-(its_domainmodel)/модель-предметной-области/объекты.html","1. Модели (its_DomainModel)/Модель предметной области/Отношения.md":"1.-модели-(its_domainmodel)/модель-предметной-области/отношения.html","1. Модели (its_DomainModel)/Модель предметной области/Перечисления (Enum).md":"1.-модели-(its_domainmodel)/модель-предметной-области/перечисления-(enum).html","1. Модели (its_DomainModel)/Модель предметной области/Свойства.md":"1.-модели-(its_domainmodel)/модель-предметной-области/свойства.html","1. Модели (its_DomainModel)/Модель предметной области/Типы данных.md":"1.-модели-(its_domainmodel)/модель-предметной-области/типы-данных.html","1. Модели (its_DomainModel)/Об its_DomainModel.md":"1.-модели-(its_domainmodel)/об-its_domainmodel.html","2. Вычисления (its_Reasoner)/Об its_Reasoner.md":"2.-вычисления-(its_reasoner)/об-its_reasoner.html","3. Наводящие вопросы (its_QuestionGen)/Об its_QuestionGen.md":"3.-наводящие-вопросы-(its_questiongen)/об-its_questiongen.html","index.md":"index.html","":"site-lib/rss.xml","images/relationship_demo.png":"images/relationship_demo.png","images/relationship_arity.png":"images/relationship_arity.png","images/relationship_linear_scale.png":"images/relationship_linear_scale.png","images/relationship_partial_scale.png":"images/relationship_partial_scale.png","images/nodes_BranchResultNode.png":"images/nodes_branchresultnode.png","images/nodes_QuestionNode.png":"images/nodes_questionnode.png","images/nodes_TupleQuestionNode.png":"images/nodes_tuplequestionnode.png","images/nodes_FindActionNode.png":"images/nodes_findactionnode.png","images/nodes_sim_and.png":"images/nodes_sim_and.png","images/nodes_sim_or.png":"images/nodes_sim_or.png","images/nodes_mutex.png":"images/nodes_mutex.png","images/nodes_hyp.png":"images/nodes_hyp.png","images/nodes_seq.png":"images/nodes_seq.png","images/nodes_BranchAggregationNode.png":"images/nodes_branchaggregationnode.png","images/nodes_CycleAggregationNode.png":"images/nodes_cycleaggregationnode.png","images/nodes_WhileCycleNode.png":"images/nodes_whilecyclenode.png","images/decision_tree_sample.png":"images/decision_tree_sample.png"},"featureOptions":{"backlinks":{"featureId":"backlinks","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".footer","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Backlinks","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"tags":{"featureId":"tags","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showInlineTags":true,"showFrontmatterTags":true,"info_showInlineTags":{"show":true,"name":"","description":"Show tags defined inside the document at the top of the page.","placeholder":""},"info_showFrontmatterTags":{"show":true,"name":"","description":"Show tags defined in the frontmatter of the document at the top of the page.","placeholder":""}},"alias":{"featureId":"aliases","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header .data-bar","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Aliases","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"properties":{"featureId":"properties","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":".header","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Properties","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"info_hideProperties":{"show":true,"name":"","description":"A list of properties to hide from the properties view","placeholder":""}},"fileNavigation":{"featureId":"file-navigation","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"showCustomIcons":false,"showDefaultFolderIcons":false,"showDefaultFileIcons":false,"defaultFolderIcon":"lucide//folder","defaultFileIcon":"lucide//file","defaultMediaIcon":"lucide//file-image","exposeStartingPath":true,"info_showCustomIcons":{"show":true,"name":"","description":"Show custom icons for files and folders","placeholder":""},"info_showDefaultFolderIcons":{"show":true,"name":"","description":"Show a default icon of a folder for every folder in the tree","placeholder":""},"info_showDefaultFileIcons":{"show":true,"name":"","description":"Show a default icon of a file for every file in the tree","placeholder":""},"info_defaultFolderIcon":{"show":true,"name":"","description":"The icon to use for folders. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultFileIcon":{"show":true,"name":"","description":"The icon to use for files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_defaultMediaIcon":{"show":true,"name":"","description":"The icon to use for media files. Prefix with 'lucide//' to use a Lucide icon","placeholder":""},"info_exposeStartingPath":{"show":true,"name":"","description":"Whether or not to show the current file in the file tree when the page is first loaded","placeholder":""},"includePath":"site-lib/html/file-tree.html"},"search":{"featureId":"search","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#left-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Search...","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"outline":{"featureId":"outline","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"На этой странице","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"startCollapsed":false,"minCollapseDepth":0,"info_startCollapsed":{"show":true,"name":"","description":"Should the outline start collapsed?","placeholder":""},"info_minCollapseDepth":{"show":true,"name":"","description":"Only allow outline items to be collapsed if they are at least this many levels deep in the tree.","placeholder":"","dropdownOptions":{"1":1,"2":2,"No Collapse":100}}},"themeToggle":{"featureId":"theme-toggle","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar .topbar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""}},"graphView":{"featureId":"graph-view","enabled":false,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"#right-sidebar-content","type":"start","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"displayTitle":"Graph View","info_displayTitle":{"show":true,"name":"","description":"Descriptive title to show above the feature","placeholder":""},"showOrphanNodes":true,"showAttachments":false,"allowGlobalGraph":true,"allowExpand":true,"attractionForce":1,"linkLength":15,"repulsionForce":80,"centralForce":2,"edgePruning":100,"minNodeRadius":3,"maxNodeRadius":7,"info_showOrphanNodes":{"show":true,"name":"","description":"Show nodes that are not connected to any other nodes.","placeholder":""},"info_showAttachments":{"show":true,"name":"","description":"Show attachments like images and PDFs as nodes in the graph.","placeholder":""},"info_allowGlobalGraph":{"show":true,"name":"","description":"Allow the user to view the global graph of all nodes.","placeholder":""},"info_allowExpand":{"show":true,"name":"","description":"Allow the user to pop-out the graph view to take up the whole screen","placeholder":""},"info_attractionForce":{"show":true,"name":"","description":"How much should linked nodes attract each other? This will make the graph appear more clustered.","placeholder":""},"info_linkLength":{"show":true,"name":"","description":"How long should the links between nodes be? The shorter the links the more connected nodes will cluster together.","placeholder":""},"info_repulsionForce":{"show":true,"name":"","description":"How much should nodes repel each other? This will make disconnected parts more spread out.","placeholder":""},"info_centralForce":{"show":true,"name":"","description":"How much should nodes be attracted to the center? This will make the graph appear more dense and circular.","placeholder":""},"info_edgePruning":{"show":true,"name":"","description":"Edges with a length above this threshold will not be rendered, however they will still contribute to the simulation. This can help large tangled graphs look more organised. Hovering over a node will still display these links.","placeholder":""},"info_minNodeRadius":{"show":true,"name":"","description":"How small should the smallest nodes be? The smaller a node is the less it will attract other nodes.","placeholder":""},"info_maxNodeRadius":{"show":true,"name":"","description":"How large should the largest nodes be? Nodes are sized by how many links they have. The larger a node is the more it will attract other nodes. This can be used to create a good grouping around the most important nodes.","placeholder":""}},"sidebar":{"featureId":"sidebar","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"allowResizing":true,"allowCollapsing":true,"rightDefaultWidth":"20em","leftDefaultWidth":"20em","info_allowResizing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be resized","placeholder":""},"info_allowCollapsing":{"show":true,"name":"","description":"Whether or not to allow the sidebars to be collapsed","placeholder":""},"info_rightDefaultWidth":{"show":true,"name":"","description":"The default width of the right sidebar","placeholder":""},"info_leftDefaultWidth":{"show":true,"name":"","description":"The default width of the left sidebar","placeholder":""}},"customHead":{"featureId":"custom-head","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"featurePlacement":{"selector":"head","type":"end","info_selector":{"show":true,"name":"","description":"CSS selector for an element. The feature will be placed relative to this element.","placeholder":""},"info_type":{"show":true,"name":"","description":"Will this feature be placed before, after, or inside (at the beggining or end).","placeholder":"","dropdownOptions":{"Before":"before","After":"after","Start":"start","End":"end"}}},"info_featurePlacement":{"show":true,"name":"","description":"Where to place this feature on the page. (Relative to the selector)","placeholder":""},"info_includePath":{"show":false,"name":"","description":"","placeholder":""},"sourcePath":"","info_sourcePath":{"show":true,"name":"","description":"The local path to the source .html file which will be included.","placeholder":"","fileInputOptions":{"makeRelativeToVault":true,"browseButton":true}},"includePath":"site-lib/html/custom-head.html"},"document":{"featureId":"obsidian-document","enabled":true,"unavailable":false,"alwaysEnabled":true,"hideSettingsButton":false,"allowFoldingLists":true,"allowFoldingHeadings":true,"documentWidth":"40em","info_allowFoldingLists":{"show":true,"name":"","description":"Whether or not to allow lists to be folded","placeholder":""},"info_allowFoldingHeadings":{"show":true,"name":"","description":"Whether or not to allow headings to be folded","placeholder":""},"info_documentWidth":{"show":true,"name":"","description":"The width of the document","placeholder":""}},"rss":{"featureId":"rss","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":false,"siteUrl":"","authorName":"","info_siteUrl":{"show":true,"name":"","description":"The url that this site will be hosted at","placeholder":"https://example.com/mysite"},"info_authorName":{"show":true,"name":"","description":"The name of the author of the site","placeholder":""}},"linkPreview":{"featureId":"link-preview","enabled":true,"unavailable":false,"alwaysEnabled":false,"hideSettingsButton":true}},"modifiedTime":1756112833034,"siteName":"Compprehensive ITS wiki","vaultName":"Compprehensive_ITS_wiki","exportRoot":"","baseURL":"","pluginVersion":"1.9.2","themeName":"","bodyClasses":"publish css-settings-manager styled-scrollbars show-inline-title show-ribbon is-focused","hasFavicon":false}